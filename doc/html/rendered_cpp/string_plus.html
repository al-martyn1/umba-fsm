<html>
<head>
<meta charset="utf-8"/>
<style>


body {
  color:#1F377F;
}

.unxp{
}

.ident{
}

/********************/
.curly{
  color:black;
}

.round{
  color:black;
}

.angle{
  color:black;
}

.square{
  color:black;
}

.op{
  color:black;
  /* font-weight: bold; */
}

/********************/
.pp{
  color:green;
}

/********************/
.pp .curly{
  /*color:#004400;*/
  /*color:#003F00;*/
  color:#004200;
}

.pp .round{
  color:#004200;
}

.pp .angle{
  color:#004200;
}

.pp .square{
  color:#004200;
}

.pp .op{
  color:#004200;
}

.pp .num{
  color:#004200;
}

.pp .cmnt{
  color:#79AF79;
}

/********************/
.cmnt{
  //color:olive;
  color:#808080;
  font-style: italic;
}

.num{
  /* color:DarkRed; */
  /*color:#7A0000;*/
  color:#6A0000;
}

.str{
  /* color:Red; */
  color:#E21F1F;
}

.kwd1{
  color:blue;
}

.kwd2{
  color:green;
}


</style>
</head>
<body>
<pre>
<span class="pp">#<span class="ident">pragma</span> <span class="ident">once</span>
</span>
<span class="cmnt">//----------------------------------------------------------------------------</span>

<span class="cmnt">/*!
    \file
    \brief Разная всячина для строк в C++ стиле
 */</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>

<span class="pp">#<span class="ident">include</span> <span class="str">&quot;alloca.h&quot;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="str">&quot;exception.h&quot;</span>
</span>
<span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">algorithm</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">cctype</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">exception</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">fstream</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">iomanip</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">iostream</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">iterator</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">locale</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">sstream</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">stdexcept</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">string</span><span class="op">&gt;</span>
</span><span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">vector</span><span class="op">&gt;</span>
</span><span class="cmnt">//----------------------------------------------------------------------------</span>



<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// ustrp::</span>
<span class="cmnt">// umba::string_plus::</span>
<span class="cmnt">// umba::cpp::</span>
<span class="cmnt">// namespace ustrp umba::cpp;</span>

<span class="kwd1">namespace</span> <span class="ident">umba</span>
<span class="curly">{</span>

<span class="kwd1">namespace</span> <span class="ident">string_plus</span>
<span class="curly">{</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">/*! \ingroup UMBA_CORE
 *  \addtogroup UMBA_STRING_PLUS
 *  @{
 */</span>
<span class="cmnt">//-----------------------------------------------------------------------------</span>



<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true для букв латиницы в нижнем регистре</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha_lower</span><span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">ch</span><span class="op">&gt;=</span><span class="str">&apos;a&apos;</span> <span class="op">&amp;&amp;</span> <span class="ident">ch</span><span class="op">&lt;=</span><span class="str">&apos;z&apos;</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//! Возвращает true для букв латиницы в верхнем регистре</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha_upper</span><span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">ch</span><span class="op">&gt;=</span><span class="str">&apos;A&apos;</span> <span class="op">&amp;&amp;</span> <span class="ident">ch</span><span class="op">&lt;=</span><span class="str">&apos;Z&apos;</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//! Возвращает true для цифровых символов ASCII</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_digit</span><span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">ch</span><span class="op">&gt;=</span><span class="str">&apos;0&apos;</span> <span class="op">&amp;&amp;</span> <span class="ident">ch</span><span class="op">&lt;=</span><span class="str">&apos;9&apos;</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true для букв латиницы в нижнем регистре</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha_lower</span><span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_lower</span><span class="round">(</span> <span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для букв латиницы в верхнем регистре</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha_upper</span><span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_upper</span><span class="round">(</span> <span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для цифровых символов ASCII</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_digit</span>      <span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_digit</span>      <span class="round">(</span> <span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//! Возвращает true для букв латиницы в нижнем регистре</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha_lower</span><span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_lower</span><span class="round">(</span> <span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для букв латиницы в верхнем регистре</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha_upper</span><span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_upper</span><span class="round">(</span> <span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для цифровых символов ASCII</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_digit</span>      <span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_digit</span>      <span class="round">(</span> <span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//! Возвращает true для букв латиницы</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha</span>      <span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>    <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_lower</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span> <span class="op">||</span> <span class="ident">is_alpha_upper</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для букв латиницы</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha</span>      <span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_lower</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span> <span class="op">||</span> <span class="ident">is_alpha_upper</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для букв латиницы</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_alpha</span>      <span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_alpha_lower</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span> <span class="op">||</span> <span class="ident">is_alpha_upper</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//! Возвращает true для символа пробела (и только для него)</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_space</span>      <span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>    <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos; &apos;</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для символа пробела (и только для него)</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_space</span>      <span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">ch</span><span class="op">==</span><span class="round">(</span><span class="ident">uint8_t</span><span class="round">)</span><span class="str">&apos; &apos;</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для символа пробела (и только для него)</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_space</span>      <span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">ch</span><span class="op">==</span><span class="ident">L</span><span class="str">&apos; &apos;</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//! Возвращает true для символа пробела или таба</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_space_ot_tab</span><span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>    <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos; &apos;</span> <span class="op">||</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\t&apos;</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для символа пробела или таба</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_space_ot_tab</span><span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_space_ot_tab</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для символа пробела или таба</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_space_ot_tab</span><span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_space_ot_tab</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//! Возвращает true для символа пробела, таба ли какого-либо из символов перевода строки</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_whitespace</span> <span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>    <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos; &apos;</span> <span class="op">||</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\r&apos;</span> <span class="op">||</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\n&apos;</span> <span class="op">||</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\t&apos;</span> <span class="op">||</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\v&apos;</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для символа пробела, таба ли какого-либо из символов перевода строки</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_whitespace</span> <span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_whitespace</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для символа пробела, таба ли какого-либо из символов перевода строки</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_whitespace</span> <span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_whitespace</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//! Возвращает true для какого-либо из символов перевода строки</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_linefeed</span> <span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span> <span class="round">)</span>    <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\r&apos;</span> <span class="op">||</span> <span class="ident">ch</span><span class="op">==</span><span class="str">&apos;\n&apos;</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для какого-либо из символов перевода строки</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_linefeed</span> <span class="round">(</span> <span class="ident">uint8_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_linefeed</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true для какого-либо из символов перевода строки</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_linefeed</span> <span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_linefeed</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает отрицание функционального объекта-предиката</span>
<span class="cmnt">/*!
    \tparam ActualPred Тип предиката
    \tparam ParamType  Тип аргумента предиката
    \return Отрицание предиката
 */</span>

<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ActualPred</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ParamType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">not_pred</span>
<span class="curly">{</span>
    <span class="kwd1">const</span> <span class="ident">ActualPred</span> <span class="op">&amp;</span><span class="ident">actualPred</span><span class="op">;</span> <span class="cmnt">//!&lt; Ссылка на предикат для отрицания его результата</span>
    <span class="cmnt">//! Конструктор предиката отрицания</span>
    <span class="ident">not_pred</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">ActualPred</span> <span class="op">&amp;</span><span class="ident">a</span> <span class="cmnt">/*!&lt; предикат для отрицания */</span> <span class="round">)</span> <span class="op">:</span> <span class="ident">actualPred</span><span class="round">(</span><span class="ident">a</span><span class="round">)</span> <span class="curly">{</span><span class="curly">}</span>
    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="ident">ParamType</span> <span class="ident">ch</span> <span class="round">)</span> <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="op">!</span><span class="ident">actualPred</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

    <span class="cmnt">// not_pred(const not_pred&amp;) = delete;</span>
    <span class="cmnt">// not_pred(not_pred&amp;&amp;) = delete;</span>
    <span class="cmnt">// not_pred&amp; operator=(const not_pred&amp;) = delete;</span>
    <span class="cmnt">// not_pred&amp; operator=(not_pred&amp;&amp;) = delete;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент - пробел</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">space_pred</span>
<span class="curly">{</span>
    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="ident">CharType</span>  <span class="ident">ch</span> <span class="round">)</span> <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_space</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

    <span class="cmnt">// space_pred() = default;</span>
    <span class="cmnt">// space_pred(const space_pred&amp;) = default;</span>
    <span class="cmnt">// space_pred(space_pred&amp;&amp;) = default;</span>
    <span class="cmnt">// space_pred&amp; operator=(const space_pred&amp;) = delete;</span>
    <span class="cmnt">// space_pred&amp; operator=(space_pred&amp;&amp;) = default;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент - пробел или таб</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">space_or_tab_pred</span>
<span class="curly">{</span>
    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">ch</span> <span class="round">)</span>  <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_space_ot_tab</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

    <span class="cmnt">// space_or_tab_pred() = default;</span>
    <span class="cmnt">// space_or_tab_pred(const space_or_tab_pred&amp;) = default;</span>
    <span class="cmnt">// space_or_tab_pred(space_or_tab_pred&amp;&amp;) = default;</span>
    <span class="cmnt">// space_or_tab_pred&amp; operator=(const space_or_tab_pred&amp;) = delete;</span>
    <span class="cmnt">// space_or_tab_pred&amp; operator=(space_or_tab_pred&amp;&amp;) = default;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент - пробел, таб, втаб, или перевод строки</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">whitespace_pred</span>
<span class="curly">{</span>
    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">ch</span> <span class="round">)</span>  <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_whitespace</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

    <span class="cmnt">// whitespace_pred() = default;</span>
    <span class="cmnt">// whitespace_pred(const whitespace_pred&amp;) = default;</span>
    <span class="cmnt">// whitespace_pred(whitespace_pred&amp;&amp;) = default;</span>
    <span class="cmnt">// whitespace_pred&amp; operator=(const whitespace_pred&amp;) = delete;</span>
    <span class="cmnt">// whitespace_pred&amp; operator=(whitespace_pred&amp;&amp;) = default;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент - перевод строки</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">linefeed_pred</span>
<span class="curly">{</span>
    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">ch</span> <span class="round">)</span>  <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_linefeed</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

    <span class="cmnt">// linefeed_pred() = default;</span>
    <span class="cmnt">// linefeed_pred(const linefeed_pred&amp;) = default;</span>
    <span class="cmnt">// linefeed_pred(linefeed_pred&amp;&amp;) = default;</span>
    <span class="cmnt">// linefeed_pred&amp; operator=(const linefeed_pred&amp;) = delete;</span>
    <span class="cmnt">// linefeed_pred&amp; operator=(linefeed_pred&amp;&amp;) = default;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент - ASCII-символ десятичной цифры</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">dec_digit_pred</span>
<span class="curly">{</span>
    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">ch</span> <span class="round">)</span>  <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_digit</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

    <span class="cmnt">// dec_digit_pred() = default;</span>
    <span class="cmnt">// dec_digit_pred(const dec_digit_pred&amp;) = default;</span>
    <span class="cmnt">// dec_digit_pred(dec_digit_pred&amp;&amp;) = default;</span>
    <span class="cmnt">// dec_digit_pred&amp; operator=(const dec_digit_pred&amp;) = delete;</span>
    <span class="cmnt">// dec_digit_pred&amp; operator=(dec_digit_pred&amp;&amp;) = default;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент входит в строку</span>
<span class="cmnt">// template&lt;typename CharType&gt;</span>
<span class="cmnt">// struct is_one_of</span>
<span class="cmnt">// {</span>
<span class="cmnt">//     const CharType *m_pstr;</span>
<span class="cmnt">//
//     is_one_of(const CharType *pstr) : m_pstr(pstr) {}</span>
<span class="cmnt">//
//     //! Оператор функционального объекта</span>
<span class="cmnt">//     bool operator()( CharType ch )  const</span>
<span class="cmnt">//     {</span>
<span class="cmnt">//         const CharType *pstr = m_pstr;</span>
<span class="cmnt">//         while(*pstr++) { if (*pstr==ch) return true; }</span>
<span class="cmnt">//         return false;</span>
<span class="cmnt">//     }</span>
<span class="cmnt">// };</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если аргумент входит в строку</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">is_one_of</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="ident">std</span><span class="op">::</span><span class="ident">basic_string</span><span class="op">&lt;</span><span class="ident">CharType</span><span class="op">&gt;</span> <span class="ident">StringType</span><span class="op">;</span>

    <span class="ident">StringType</span> <span class="ident">m_str</span><span class="op">;</span>

    <span class="ident">is_one_of</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span> <span class="op">:</span> <span class="ident">m_str</span><span class="round">(</span><span class="ident">str</span><span class="round">)</span> <span class="curly">{</span><span class="curly">}</span>
    <span class="ident">is_one_of</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">CharType</span>   <span class="op">*</span><span class="ident">pstr</span><span class="round">)</span> <span class="op">:</span> <span class="ident">m_str</span><span class="round">(</span><span class="ident">pstr</span><span class="round">)</span> <span class="curly">{</span><span class="curly">}</span>

    <span class="cmnt">//! Оператор функционального объекта</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">ch</span> <span class="round">)</span>  <span class="kwd1">const</span>
    <span class="curly">{</span>
        <span class="kwd1">return</span> <span class="ident">m_str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">!=</span><span class="ident">m_str</span><span class="op">.</span><span class="ident">npos</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="ident">is_one_of</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">is_one_of</span><span class="op">&amp;</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">default</span><span class="op">;</span>
    <span class="ident">is_one_of</span><span class="round">(</span><span class="ident">is_one_of</span><span class="op">&amp;&amp;</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">default</span><span class="op">;</span>
    <span class="ident">is_one_of</span><span class="op">&amp;</span> <span class="kwd1">operator</span><span class="op">=</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">is_one_of</span><span class="op">&amp;</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">delete</span><span class="op">;</span>
    <span class="ident">is_one_of</span><span class="op">&amp;</span> <span class="kwd1">operator</span><span class="op">=</span><span class="round">(</span><span class="ident">is_one_of</span><span class="op">&amp;&amp;</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">default</span><span class="op">;</span>

<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Trims</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Левый inplace trim с предикатом</span>
<span class="cmnt">/*! \tparam StringType Тип входной строки (std::basic_string)
    \tparam TrimPred   Предикат. Должен возвращать true для тех символов, которые необходимо обрезать
    \param s           Входная строка
    \param pred        Экземпляр предиката
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">ltrim</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">s</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span><span class="ident">s</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">std</span><span class="op">::</span><span class="ident">find_if</span><span class="round">(</span><span class="ident">s</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">s</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">not_pred</span><span class="op">&lt;</span><span class="ident">TrimPred</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">pred</span><span class="round">)</span> <span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Правый inplace trim с предикатом</span>
<span class="cmnt">/*! \copydetails ltrim */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span> <span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">rtrim</span><span class="round">(</span><span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">s</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">find_if</span><span class="round">(</span><span class="ident">s</span><span class="op">.</span><span class="ident">rbegin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">s</span><span class="op">.</span><span class="ident">rend</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">not_pred</span><span class="op">&lt;</span><span class="ident">TrimPred</span><span class="op">,</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">pred</span><span class="round">)</span> <span class="round">)</span><span class="op">.</span><span class="ident">base</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">s</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Двусторонний inplace trim с предикатом</span>
<span class="cmnt">/*! \copydetails ltrim */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">trim</span><span class="round">(</span><span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ltrim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span> <span class="ident">rtrim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Левый inplace trim. Обрезает пробелы и табы</span>
<span class="cmnt">/*! \tparam StringType Тип входной строки (std::basic_string)
    \param s           Входная строка
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">ltrim</span><span class="round">(</span><span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ltrim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span> <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Правый inplace trim. Обрезает пробелы и табы</span>
<span class="cmnt">/*! \tparam StringType Тип входной строки (std::basic_string)
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">rtrim</span><span class="round">(</span><span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">rtrim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span> <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Двусторонний inplace trim. Обрезает пробелы и табы</span>
<span class="cmnt">/*! \tparam StringType Тип входной строки (std::basic_string)
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">trim</span><span class="round">(</span><span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">trim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Левый copy trim с предикатом</span>
<span class="cmnt">/*! \tparam StringType Тип входной и результирующей строки (std::basic_string)
    \tparam TrimPred   Предикат. Должен возвращать true для тех символов, которые необходимо обрезать
    \param s           Входная строка
    \param pred        Экземпляр предиката
    \returns           Обрезанную строку
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">ltrim_copy</span><span class="round">(</span><span class="ident">StringType</span> <span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ltrim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">s</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Правый copy trim с предикатом</span>
<span class="cmnt">/*! \copydetails ltrim */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">rtrim_copy</span><span class="round">(</span><span class="ident">StringType</span> <span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">rtrim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">s</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Двусторонний copy trim с предикатом</span>
<span class="cmnt">/*! \copydetails ltrim */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">trim_copy</span><span class="round">(</span><span class="ident">StringType</span> <span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">trim</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">s</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Левый copy trim</span>
<span class="cmnt">/*! \tparam StringType Тип входной и результирующей строки (std::basic_string)
    \param s           Входная строка
    \returns           Обрезанную строку
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">ltrim_copy</span><span class="round">(</span><span class="ident">StringType</span> <span class="ident">s</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">ltrim_copy</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Правый copy trim с предикатом</span>
<span class="cmnt">/*! \tparam StringType Тип входной и результирующей строки (std::basic_string)
    \param s           Входная строка
    \returns           Обрезанную строку
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">rtrim_copy</span><span class="round">(</span><span class="ident">StringType</span> <span class="ident">s</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">rtrim_copy</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Двусторонний copy trim</span>
<span class="cmnt">/*! \tparam StringType Тип входной и результирующей строки (std::basic_string)
    \param s           Входная строка
    \returns           Обрезанную строку
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">trim_copy</span><span class="round">(</span><span class="ident">StringType</span> <span class="ident">s</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">trim_copy</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span><span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//#endif // UMBA_CXX_HAS_STD11</span>
<span class="cmnt">//-----------------------------------------------------------------------------</span>






<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_iter_ltrim</span><span class="round">(</span> <span class="ident">IteratorType</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">IteratorType</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">b</span><span class="op">!=</span><span class="ident">e</span><span class="op">;</span> <span class="op">++</span><span class="ident">b</span><span class="round">)</span>
        <span class="ident">ltrim</span><span class="round">(</span><span class="op">*</span><span class="ident">b</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span> <span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_iter_rtrim</span><span class="round">(</span><span class="ident">IteratorType</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">IteratorType</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">b</span><span class="op">!=</span><span class="ident">e</span><span class="op">;</span> <span class="op">++</span><span class="ident">b</span><span class="round">)</span>
        <span class="ident">rtrim</span><span class="round">(</span><span class="op">*</span><span class="ident">b</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_iter_trim</span><span class="round">(</span><span class="ident">IteratorType</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">IteratorType</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">b</span><span class="op">!=</span><span class="ident">e</span><span class="op">;</span> <span class="op">++</span><span class="ident">b</span><span class="round">)</span>
        <span class="ident">trim</span><span class="round">(</span><span class="op">*</span><span class="ident">b</span><span class="op">,</span><span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_iter_ltrim</span><span class="round">(</span><span class="ident">IteratorType</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">IteratorType</span> <span class="ident">e</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">::</span><span class="ident">value_type</span>                           <span class="ident">StringType</span><span class="op">;</span>
    <span class="kwd1">typedef</span>          <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span>   <span class="ident">TrimPred</span><span class="op">;</span>
    <span class="ident">cont_iter_ltrim</span><span class="op">&lt;</span><span class="ident">IteratorType</span><span class="op">,</span><span class="ident">TrimPred</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">b</span><span class="op">,</span><span class="ident">e</span><span class="op">,</span><span class="ident">TrimPred</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_iter_rtrim</span><span class="round">(</span><span class="ident">IteratorType</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">IteratorType</span> <span class="ident">e</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">::</span><span class="ident">value_type</span>                           <span class="ident">StringType</span><span class="op">;</span>
    <span class="kwd1">typedef</span>          <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span>   <span class="ident">TrimPred</span><span class="op">;</span>
    <span class="ident">cont_iter_rtrim</span><span class="op">&lt;</span><span class="ident">IteratorType</span><span class="op">,</span><span class="ident">TrimPred</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">b</span><span class="op">,</span><span class="ident">e</span><span class="op">,</span><span class="ident">TrimPred</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span>  <span class="ident">cont_iter_trim</span><span class="round">(</span><span class="ident">IteratorType</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">IteratorType</span> <span class="ident">e</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">IteratorType</span><span class="op">::</span><span class="ident">value_type</span>                           <span class="ident">StringType</span><span class="op">;</span>
    <span class="kwd1">typedef</span>          <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span>   <span class="ident">TrimPred</span><span class="op">;</span>
    <span class="ident">cont_iter_trim</span> <span class="op">&lt;</span><span class="ident">IteratorType</span><span class="op">,</span><span class="ident">TrimPred</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">b</span><span class="op">,</span><span class="ident">e</span><span class="op">,</span><span class="ident">TrimPred</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_ltrim</span><span class="round">(</span> <span class="ident">ContainerType</span> <span class="op">&amp;</span><span class="ident">c</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">cont_iter_ltrim</span><span class="round">(</span><span class="ident">c</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">c</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span> <span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_rtrim</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="op">&amp;</span><span class="ident">c</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">cont_iter_rtrim</span><span class="round">(</span><span class="ident">c</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">c</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_trim</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="op">&amp;</span><span class="ident">c</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">cont_iter_trim</span><span class="round">(</span><span class="ident">c</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">c</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">pred</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_ltrim</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="op">&amp;</span><span class="ident">c</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">::</span><span class="ident">value_type</span>                          <span class="ident">StringType</span><span class="op">;</span>
    <span class="kwd1">typedef</span>          <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span>   <span class="ident">TrimPred</span><span class="op">;</span>
    <span class="ident">cont_ltrim</span><span class="op">&lt;</span><span class="ident">ContainerType</span><span class="op">,</span><span class="ident">TrimPred</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">c</span><span class="op">,</span><span class="ident">TrimPred</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">cont_rtrim</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="op">&amp;</span><span class="ident">c</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">::</span><span class="ident">value_type</span>                          <span class="ident">StringType</span><span class="op">;</span>
    <span class="kwd1">typedef</span>          <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span>   <span class="ident">TrimPred</span><span class="op">;</span>
    <span class="ident">cont_rtrim</span><span class="op">&lt;</span><span class="ident">ContainerType</span><span class="op">,</span><span class="ident">TrimPred</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">c</span><span class="op">,</span><span class="ident">TrimPred</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span>  <span class="ident">cont_trim</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="op">&amp;</span><span class="ident">c</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">::</span><span class="ident">value_type</span>                          <span class="ident">StringType</span><span class="op">;</span>
    <span class="kwd1">typedef</span>          <span class="ident">whitespace_pred</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span>   <span class="ident">TrimPred</span><span class="op">;</span>
    <span class="ident">cont_trim</span><span class="op">&lt;</span><span class="ident">ContainerType</span><span class="op">,</span><span class="ident">TrimPred</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">c</span><span class="op">,</span><span class="ident">TrimPred</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">ContainerType</span> <span class="ident">cont_ltrim_copy</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="ident">c</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ContainerType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">c</span><span class="op">;</span> <span class="ident">cont_ltrim</span><span class="round">(</span> <span class="ident">res</span><span class="op">,</span> <span class="ident">pred</span> <span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">ContainerType</span> <span class="ident">cont_rtrim_copy</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="ident">c</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ContainerType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">c</span><span class="op">;</span> <span class="ident">cont_rtrim</span><span class="round">(</span> <span class="ident">res</span><span class="op">,</span> <span class="ident">pred</span> <span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">TrimPred</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">ContainerType</span>  <span class="ident">cont_trim_copy</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="ident">c</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">TrimPred</span> <span class="op">&amp;</span><span class="ident">pred</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ContainerType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">c</span><span class="op">;</span> <span class="ident">cont_trim</span><span class="round">(</span> <span class="ident">res</span><span class="op">,</span> <span class="ident">pred</span> <span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">ContainerType</span> <span class="ident">cont_ltrim_copy</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="ident">c</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ContainerType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">c</span><span class="op">;</span> <span class="ident">cont_ltrim</span><span class="round">(</span> <span class="ident">res</span> <span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">ContainerType</span> <span class="ident">cont_rtrim_copy</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="ident">c</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ContainerType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">c</span><span class="op">;</span> <span class="ident">cont_rtrim</span><span class="round">(</span> <span class="ident">res</span> <span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">ContainerType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">ContainerType</span>  <span class="ident">cont_trim_copy</span><span class="round">(</span><span class="ident">ContainerType</span> <span class="ident">c</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">ContainerType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">c</span><span class="op">;</span> <span class="ident">cont_trim</span><span class="round">(</span> <span class="ident">res</span> <span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>





<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Starts/Ends</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка начинается с указанного префикса (StringType)</span>
<span class="cmnt">/*! \tparam StringType Тип входной и результирующей строки (std::basic_string)
    \param str         Входная строка
    \param prefix      Префикс, есть перегрузка для const StringType::value_type*
    \returns           true, если строка начинается с указанного префикса
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">starts_with</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">prefix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">&lt;</span><span class="ident">prefix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="ident">str</span><span class="op">.</span><span class="ident">compare</span><span class="round">(</span> <span class="num">0</span><span class="op">,</span> <span class="ident">prefix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">prefix</span> <span class="round">)</span><span class="op">==</span><span class="num">0</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка начинается с указанного префикса (StringType::value_type*)</span>
<span class="cmnt">/*! \copydetails starts_with */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">starts_with</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">prefix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">starts_with</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">prefix</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка начинается с указанного префикса (StringType), удаляя префикс</span>
<span class="cmnt">/*! \copydetails starts_with */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">starts_with_and_strip</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">prefix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">starts_with</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">prefix</span> <span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="ident">str</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span> <span class="num">0</span><span class="op">,</span> <span class="ident">prefix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка начинается с указанного префикса (StringType::value_type*), удаляя префикс</span>
<span class="cmnt">/*! \copydetails starts_with */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">starts_with_and_strip</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">prefix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">starts_with_and_strip</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">prefix</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка заканчивается на указанный постфикс (StringType)</span>
<span class="cmnt">/*! \tparam StringType Тип входной и результирующей строки (std::basic_string)
    \param str         Входная строка
    \param postfix     Постфикс (суффикс), есть перегрузка для const StringType::value_type*
    \returns           true, если строка начинается с указанного постфикса
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">ends_with</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">postfix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">&lt;</span><span class="ident">postfix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="ident">str</span><span class="op">.</span><span class="ident">compare</span><span class="round">(</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">-</span><span class="ident">postfix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">postfix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">postfix</span> <span class="round">)</span><span class="op">==</span><span class="num">0</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка заканчивается на указанный постфикс (StringType::value_type*)</span>
<span class="cmnt">/*! \copydetails ends_with */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">ends_with</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">postfix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">ends_with</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">postfix</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка заканчивается на указанный постфикс (StringType), удаляя постфикс</span>
<span class="cmnt">/*! \copydetails ends_with */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span>  <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">ends_with_and_strip</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">postfix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">ends_with</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">postfix</span> <span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="ident">str</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">-</span><span class="ident">postfix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">postfix</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка заканчивается на указанный постфикс (StringType::value_type*), удаляя постфикс</span>
<span class="cmnt">/*! \copydetails ends_with */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">ends_with_and_strip</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">postfix</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">ends_with_and_strip</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">postfix</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>





<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Case conversion</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Конвертирует строку StringType в нижний регистр (работает только для базового диапазона ASCII)</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">tolower</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">iterator</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="ident">it</span> <span class="op">!=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="op">++</span><span class="ident">it</span><span class="round">)</span>
        <span class="op">*</span><span class="ident">it</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="ident">std</span><span class="op">::</span><span class="ident">tolower</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="op">*</span><span class="ident">it</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Конвертирует строку StringType в верхний регистр (работает только для базового диапазона ASCII)</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">toupper</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">iterator</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="ident">it</span> <span class="op">!=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="op">++</span><span class="ident">it</span><span class="round">)</span>
        <span class="op">*</span><span class="ident">it</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="ident">std</span><span class="op">::</span><span class="ident">toupper</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="op">*</span><span class="ident">it</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Не меняет регистр символов</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">void</span> <span class="ident">tosamecase</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span> <span class="curly">{</span> <span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Конвертирует строку StringType в нижний регистр (работает только для базового диапазона ASCII), возвращая модифицированную копию</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">tolower_copy</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">str</span><span class="op">;</span>
    <span class="ident">tolower</span><span class="round">(</span><span class="ident">res</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Конвертирует строку StringType в верхний регистр (работает только для базового диапазона ASCII), возвращая модифицированную копию</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">toupper_copy</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">str</span><span class="op">;</span>
    <span class="ident">toupper</span><span class="round">(</span><span class="ident">res</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Не меняет регистр символов, возвращая копию входного аргумента</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">tosamecase_copy</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">str</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Создаёт строку StringType из std::wstring (работает только для базового диапазона ASCII).</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">make_string</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span><span class="op">::</span><span class="ident">const_iterator</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="ident">it</span> <span class="op">!=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="op">++</span><span class="ident">it</span><span class="round">)</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="op">*</span><span class="ident">it</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Создаёт строку StringType из std::string (работает только для базового диапазона ASCII).</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">make_string</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">::</span><span class="ident">const_iterator</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="ident">it</span> <span class="op">!=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="op">++</span><span class="ident">it</span><span class="round">)</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="op">*</span><span class="ident">it</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Создаёт строку StringType из const wchar_t* (работает только для базового диапазона ASCII).</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">make_string</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="op">*</span><span class="ident">str</span><span class="op">;</span> <span class="ident">str</span><span class="op">++</span><span class="round">)</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="op">*</span><span class="ident">str</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Создаёт строку StringType из const char* (работает только для базового диапазона ASCII).</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">make_string</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">char</span> <span class="op">*</span><span class="ident">str</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="op">*</span><span class="ident">str</span><span class="op">;</span> <span class="ident">str</span><span class="op">++</span><span class="round">)</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="op">*</span><span class="ident">str</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Создаёт строку StringType из sz wchar_t&apos;ов (работает только для базового диапазона ASCII).</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">make_string</span><span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">ch</span><span class="op">,</span> <span class="ident">size_t</span> <span class="ident">sz</span> <span class="op">=</span> <span class="num">1</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">sz</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Создаёт строку StringType из sz char&apos;ов (работает только для базового диапазона ASCII).</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">StringType</span> <span class="ident">make_string</span><span class="round">(</span> <span class="kwd1">char</span> <span class="ident">ch</span><span class="op">,</span> <span class="ident">size_t</span> <span class="ident">sz</span> <span class="op">=</span> <span class="num">1</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">sz</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>





<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! &quot;Сжатие&quot; строки. Несколько последовательно повторяющихся символов склеиваются в один</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">textCompress</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">text</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">compressChars</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">i</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">sz</span> <span class="op">=</span> <span class="ident">text</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">prevWs</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>

    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">i</span><span class="op">!=</span><span class="ident">sz</span><span class="op">;</span> <span class="op">++</span><span class="ident">i</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">ch</span> <span class="op">=</span> <span class="ident">text</span><span class="square">[</span><span class="ident">i</span><span class="square">]</span><span class="op">;</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">chPos</span> <span class="op">=</span> <span class="ident">compressChars</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
        <span class="cmnt">//if (ch==&apos; &apos; || ch==&apos;\t&apos;)</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">chPos</span><span class="op">!=</span><span class="ident">compressChars</span><span class="op">.</span><span class="ident">npos</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">ch</span><span class="op">==</span><span class="ident">prevWs</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="cmnt">// simple skip</span>
            <span class="curly">}</span>
            <span class="kwd1">else</span>
            <span class="curly">{</span>
                <span class="ident">prevWs</span> <span class="op">=</span> <span class="ident">ch</span><span class="op">;</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
            <span class="curly">}</span>
        <span class="curly">}</span>
        <span class="kwd1">else</span>
        <span class="curly">{</span>
            <span class="ident">prevWs</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
            <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
        <span class="curly">}</span>
    <span class="curly">}</span>

    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Split/Merge</span>


<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param b            Итератор начала последовательности
    \param e            Итератор конца последовательности
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="op">&amp;</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">_delim</span> <span class="op">=</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">delim</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span> <span class="op">;</span> <span class="ident">b</span><span class="op">!=</span><span class="ident">e</span><span class="op">;</span> <span class="op">++</span><span class="ident">b</span> <span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">res</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span> <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">_delim</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">stringifier</span><span class="round">(</span><span class="op">*</span><span class="ident">b</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param b            Итератор начала последовательности
    \param e            Итератор конца последовательности
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="op">&amp;</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">StringType</span> <span class="ident">_delim</span> <span class="op">=</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">delim</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span> <span class="op">;</span> <span class="ident">b</span><span class="op">!=</span><span class="ident">e</span><span class="op">;</span> <span class="op">++</span><span class="ident">b</span> <span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">res</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span> <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">_delim</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">stringifier</span><span class="round">(</span><span class="op">*</span><span class="ident">b</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param b            Итератор начала последовательности
    \param e            Итератор конца последовательности
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">char</span> <span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">delim</span><span class="op">,</span><span class="num">1</span><span class="round">)</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param b            Итератор начала последовательности
    \param e            Итератор конца последовательности
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">char</span> <span class="op">*</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">delim</span><span class="round">)</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param b            Итератор начала последовательности
    \param e            Итератор конца последовательности
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">wchar_t</span> <span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">delim</span><span class="op">,</span><span class="num">1</span><span class="round">)</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param b            Итератор начала последовательности
    \param e            Итератор конца последовательности
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">delim</span><span class="round">)</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam ItemType    Тип элемента/объекта
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ItemType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">ItemType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">char</span> <span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam ItemType    Тип элемента/объекта
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ItemType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">ItemType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">char</span> <span class="op">*</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam ItemType    Тип элемента/объекта
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ItemType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">ItemType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="op">&amp;</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam ItemType    Тип элемента/объекта
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ItemType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">ItemType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">wchar_t</span> <span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam ItemType    Тип элемента/объекта
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ItemType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">ItemType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строковых представлений объектов в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam ItemType    Тип элемента/объекта
    \tparam ToStringObj Тип преобразователя в строку. operator( *Iter ) должен возвращать значение типа StringType

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t
    \param stringifier  Экземпляр объекта-преобразователя в строку

    \return Результат слияния строковых представлений объектов
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ItemType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">ToStringObj</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">ItemType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="op">&amp;</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">ToStringObj</span> <span class="op">&amp;</span><span class="ident">stringifier</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">stringifier</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>




<span class="cmnt">//----------------------------------------------------------------------------</span>
<span class="cmnt">//! Просто возвращает свой аргумент. Типа вместо лямбды</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">T</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">lambda_return_arg</span>
<span class="curly">{</span>
    <span class="cmnt">//! Возвращает свой аргумент</span>
    <span class="ident">T</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">T</span> <span class="op">&amp;</span><span class="ident">t</span> <span class="round">)</span> <span class="kwd1">const</span> <span class="curly">{</span>  <span class="kwd1">return</span> <span class="ident">t</span><span class="op">;</span> <span class="curly">}</span>
<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Возвращает true, если объект empty(). Типа вместо лямбды</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">T</span><span class="op">&gt;</span>
<span class="kwd1">struct</span> <span class="ident">lambda_is_empty</span>
<span class="curly">{</span>
    <span class="cmnt">//! Возвращает результат вызова empty() для своего аргумента</span>
    <span class="kwd1">bool</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">T</span> <span class="op">&amp;</span><span class="ident">t</span> <span class="round">)</span> <span class="kwd1">const</span>  <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">t</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>




<span class="cmnt">//----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам

    \param b            Итератор начала последовательности строк
    \param e            Итератор конца последовательности строк
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">char</span> <span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам

    \param b            Итератор начала последовательности строк
    \param e            Итератор конца последовательности строк
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">char</span> <span class="op">*</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам

    \param b            Итератор начала последовательности строк
    \param e            Итератор конца последовательности строк
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="op">&amp;</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам

    \param b            Итератор начала последовательности строк
    \param e            Итератор конца последовательности строк
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">wchar_t</span> <span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам

    \param b            Итератор начала последовательности строк
    \param e            Итератор конца последовательности строк
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)
    \tparam Iter        Тип итератора по объектам

    \param b            Итератор начала последовательности строк
    \param e            Итератор конца последовательности строк
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">Iter</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="ident">Iter</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">Iter</span> <span class="ident">e</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="op">&amp;</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">b</span><span class="op">,</span> <span class="ident">e</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">char</span> <span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">char</span> <span class="op">*</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="op">&amp;</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">wchar_t</span> <span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Производит слияние строк в одну строку</span>
<span class="cmnt">/*!
    \tparam StringType  Тип результирующей строки (std::basic_string)

    \param tokens       Вектор элементов для склеивания в строку
    \param delim        Разделитель элементов в результирующей строке. Перегружен для std::string, std::wstring, const char*, const wchar_t*, char, wchar_t

    \return Результат слияния строк
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">merge</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">tokens</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="op">&amp;</span><span class="ident">delim</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">merge</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">tokens</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">delim</span><span class="op">,</span> <span class="ident">lambda_return_arg</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Misc string algorithms</span>


<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Расширение строки до нужной длины</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">expand</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>                                                            <span class="cmnt">//!&lt; Расширяемая строка</span>
           <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">sz</span>                                          <span class="cmnt">//!&lt; Требуемый размер</span>
           <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">ch</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="str">&apos; &apos;</span>  <span class="cmnt">//!&lt; Символ заполнения</span>
           <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">&gt;=</span><span class="ident">sz</span><span class="round">)</span>
        <span class="kwd1">return</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">numCharsToAdd</span> <span class="op">=</span> <span class="ident">sz</span> <span class="op">-</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">str</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span> <span class="ident">numCharsToAdd</span><span class="op">,</span> <span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Расширение копии строки до нужной длины. \returns Расширеную строку.</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">expand_copy</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>                                                      <span class="cmnt">//!&lt; Расширяемая строка</span>
                      <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">sz</span>                                          <span class="cmnt">//!&lt; Требуемый размер</span>
                      <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">ch</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="str">&apos; &apos;</span>  <span class="cmnt">//!&lt; Символ заполнения</span>
                      <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">str</span><span class="op">;</span>
    <span class="ident">expand</span><span class="round">(</span><span class="ident">res</span><span class="op">,</span> <span class="ident">sz</span><span class="op">,</span> <span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Brace utils</span>


<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Хелперы для разного скобочного</span>
<span class="kwd1">namespace</span> <span class="ident">ascii_brace</span>
<span class="curly">{</span>


<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Возвращает парный символ для своего аргумента (только из диапазона ASCII)</span>
<span class="kwd1">inline</span> <span class="kwd1">char</span> <span class="ident">get_pair</span><span class="round">(</span> <span class="kwd1">char</span> <span class="ident">brCh</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">switch</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">case</span> <span class="str">&apos;&lt;&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;&gt;&apos;</span> <span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;&gt;&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;&lt;&apos;</span> <span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;[&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;]&apos;</span> <span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;]&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;[&apos;</span> <span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;{&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;}&apos;</span> <span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;}&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;{&apos;</span> <span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;(&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;)&apos;</span> <span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;)&apos;</span> <span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;(&apos;</span> <span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;\&apos;&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;\&apos;&apos;</span><span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;\&quot;&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;\&quot;&apos;</span><span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;%&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;%&apos;</span><span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;$&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;$&apos;</span><span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;@&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;@&apos;</span><span class="op">;</span>
        <span class="kwd1">case</span> <span class="str">&apos;#&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;#&apos;</span><span class="op">;</span>

        <span class="kwd1">case</span> <span class="str">&apos;_&apos;</span><span class="op">:</span> <span class="kwd1">return</span> <span class="str">&apos;_&apos;</span><span class="op">;</span>

        <span class="kwd1">default</span>  <span class="op">:</span> <span class="kwd1">return</span> <span class="num">0</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Возвращает парный символ для своего аргумента (только из диапазона ASCII)</span>
<span class="kwd1">inline</span> <span class="kwd1">wchar_t</span> <span class="ident">get_pair</span><span class="round">(</span> <span class="kwd1">wchar_t</span> <span class="ident">brCh</span> <span class="round">)</span>  <span class="curly">{</span> <span class="kwd1">return</span> <span class="round">(</span><span class="kwd1">wchar_t</span><span class="round">)</span><span class="ident">get_pair</span><span class="round">(</span><span class="round">(</span><span class="kwd1">char</span><span class="round">)</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Возвращает true, если входной символ - скобка (только из диапазона ASCII)</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_brace</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">CharType</span> <span class="ident">pr</span> <span class="op">=</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">pr</span> <span class="op">!=</span> <span class="num">0</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Сравнивает два символа. Возвращает -1, 0, 1. Вообще-то предполагалось для скобок, но работает для любых символов. Если результат меньше нуля, то br1 - открывающая скобка</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">int</span> <span class="ident">compare</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">br1</span><span class="op">,</span> <span class="ident">CharType</span> <span class="ident">br2</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">br1</span><span class="op">==</span><span class="ident">br2</span><span class="round">)</span> <span class="kwd1">return</span> <span class="num">0</span><span class="op">;</span>
    <span class="kwd1">else</span> <span class="kwd1">return</span> <span class="ident">br1</span><span class="op">&lt;</span><span class="ident">br2</span> <span class="op">?</span> <span class="op">-</span><span class="num">1</span> <span class="op">:</span> <span class="num">1</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">has_pair</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">CharType</span> <span class="ident">pr</span> <span class="op">=</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">pr</span> <span class="op">!=</span> <span class="num">0</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_openclose_char</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">CharType</span> <span class="ident">pr</span> <span class="op">=</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">pr</span><span class="op">!=</span><span class="num">0</span> <span class="op">&amp;&amp;</span> <span class="ident">pr</span><span class="op">!=</span><span class="ident">brCh</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_open_brace_char</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">CharType</span> <span class="ident">pr</span> <span class="op">=</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">pr</span><span class="op">==</span><span class="num">0</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">pr</span><span class="op">==</span><span class="ident">brCh</span><span class="round">)</span> <span class="cmnt">// такая же, а не парная</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="ident">brCh</span> <span class="op">&lt;</span> <span class="ident">pr</span><span class="op">;</span> <span class="cmnt">// Символ переданный аргументом - левее найденного в ASCII - значит открывающая</span>
<span class="curly">}</span>


<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Возвращает true, если переданный символ - парный (один из видов скобки) или апостроф, кавычка, или %, $, @, # - они тоже считаются парными</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_paired</span>    <span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">compare</span> <span class="round">(</span> <span class="ident">brCh</span>  <span class="op">,</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span> <span class="round">)</span> <span class="op">!=</span> <span class="num">0</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true, если символ - открывающий - левый</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_left</span>      <span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">compare</span> <span class="round">(</span> <span class="ident">brCh</span>  <span class="op">,</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span> <span class="round">)</span>  <span class="op">&lt;</span> <span class="num">0</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает true, если символ - закрывающий - правый</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">is_right</span>     <span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">compare</span> <span class="round">(</span> <span class="ident">brCh</span>  <span class="op">,</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span> <span class="round">)</span>  <span class="op">&gt;</span> <span class="num">0</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает парный левый символ</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">CharType</span> <span class="ident">get_left</span> <span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_left</span> <span class="round">(</span> <span class="ident">brCh</span><span class="round">)</span> <span class="op">?</span> <span class="ident">brCh</span> <span class="op">:</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает парный левый символ</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CharType</span><span class="op">&gt;</span> <span class="kwd1">inline</span> <span class="ident">CharType</span> <span class="ident">get_right</span><span class="round">(</span> <span class="ident">CharType</span> <span class="ident">brCh</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">is_right</span><span class="round">(</span> <span class="ident">brCh</span><span class="round">)</span> <span class="op">?</span> <span class="ident">brCh</span> <span class="op">:</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">brCh</span><span class="round">)</span><span class="op">;</span><span class="curly">}</span>

<span class="cmnt">//------------------------------</span>




<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Создаёт наборы левых и правых скобок для входного набора, в котором можно задавать как левые, так и правые варианты. На входе должны быть только символы, имеющие пару. Типа нормализация</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">build_pairs</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">braces</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">*</span><span class="ident">pLefts</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">*</span><span class="ident">pRights</span> <span class="op">=</span> <span class="num">0</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">CharType</span><span class="op">;</span>
    <span class="cmnt">//lefts .clear(); lefts .reserve(8);</span>
    <span class="cmnt">//rights.clear(); rights.reserve(8);</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">pLefts</span><span class="op">==</span><span class="num">0</span> <span class="op">&amp;&amp;</span> <span class="ident">pRights</span><span class="op">==</span><span class="num">0</span><span class="round">)</span>
        <span class="kwd1">return</span><span class="op">;</span>

    <span class="ident">StringType</span> <span class="ident">lefts</span><span class="op">,</span> <span class="ident">rights</span><span class="op">;</span>
    <span class="ident">lefts</span> <span class="op">.</span><span class="ident">reserve</span><span class="round">(</span><span class="num">8</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">rights</span><span class="op">.</span><span class="ident">reserve</span><span class="round">(</span><span class="num">8</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">while</span><span class="round">(</span><span class="op">*</span><span class="ident">braces</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">CharType</span> <span class="ident">b</span> <span class="op">=</span> <span class="op">*</span><span class="ident">braces</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">is_left</span><span class="round">(</span><span class="ident">b</span><span class="round">)</span><span class="op">==</span><span class="ident">is_right</span><span class="round">(</span><span class="ident">b</span><span class="round">)</span><span class="round">)</span>
            <span class="kwd1">throw</span> <span class="ident">std</span><span class="op">::</span><span class="ident">runtime_error</span><span class="round">(</span><span class="str">&quot;umba::cpp::ascii_brace::build_pairs (1): paired brace can&apos;t be left and right at the same time&quot;</span><span class="round">)</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">is_paired</span><span class="round">(</span><span class="ident">b</span><span class="round">)</span><span class="round">)</span>
            <span class="kwd1">throw</span> <span class="ident">std</span><span class="op">::</span><span class="ident">runtime_error</span><span class="round">(</span><span class="str">&quot;umba::cpp::ascii_brace::build_pairs (2): can&apos;t build pair for non-paired brace&quot;</span><span class="round">)</span><span class="op">;</span>

        <span class="kwd1">bool</span> <span class="ident">isLeft</span> <span class="op">=</span> <span class="ident">is_left</span><span class="round">(</span><span class="ident">b</span><span class="round">)</span><span class="op">;</span>

        <span class="ident">CharType</span> <span class="ident">lb</span> <span class="op">=</span>  <span class="ident">isLeft</span> <span class="op">?</span> <span class="ident">b</span> <span class="op">:</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">b</span><span class="round">)</span><span class="op">;</span> <span class="cmnt">// if left we keep, else we got the pair</span>
        <span class="ident">CharType</span> <span class="ident">rb</span> <span class="op">=</span> <span class="op">!</span><span class="ident">isLeft</span> <span class="op">?</span> <span class="ident">b</span> <span class="op">:</span> <span class="ident">get_pair</span><span class="round">(</span><span class="ident">b</span><span class="round">)</span><span class="op">;</span> <span class="cmnt">// if not left we got the pair, else - keep</span>

        <span class="ident">lefts</span> <span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">lb</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">rights</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">rb</span><span class="round">)</span><span class="op">;</span>

        <span class="op">++</span><span class="ident">braces</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">pLefts</span> <span class="round">)</span> <span class="op">*</span><span class="ident">pLefts</span>  <span class="op">=</span> <span class="ident">lefts</span> <span class="op">;</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">pRights</span><span class="round">)</span> <span class="op">*</span><span class="ident">pRights</span> <span class="op">=</span> <span class="ident">rights</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Создаёт наборы левых и правых скобок для входного набора, в котором можно задавать как левые, так и правые варианты. На входе должны быть только символы, имеющие пару. Типа нормализация</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">build_pairs</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">*</span><span class="ident">pLefts</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">*</span><span class="ident">pRights</span> <span class="op">=</span> <span class="num">0</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">build_pairs</span><span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">c_str</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">pLefts</span><span class="op">,</span> <span class="ident">pRights</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Создаёт наборы левых и правых скобок для входного набора, в котором можно задавать как левые, так и правые варианты. На входе должны быть только символы, имеющие пару. Типа нормализация</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">build_pairs</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">braces</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">lefts</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">rights</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">build_pairs</span><span class="round">(</span> <span class="ident">braces</span><span class="op">.</span><span class="ident">c_str</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="op">&amp;</span><span class="ident">lefts</span><span class="op">,</span> <span class="op">&amp;</span><span class="ident">rights</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Утилита. Пробегаем последовательно по вектору счётчиков, сравниваем с параметром, возвращаем true, только если все значения равны заданному параметру.</span>
<span class="cmnt">/*!
    \tparam CounterType Тип счётчика

    \param cntVec       Вектор счётчиков
    \param val          Величина для сравнения

    \return             Возвращает true, только если все значения равны заданному параметру
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">CounterType</span><span class="op">&gt;</span>
<span class="kwd1">inline</span> <span class="kwd1">bool</span> <span class="ident">util_check_all_exact</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">CounterType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">cntVec</span><span class="op">,</span> <span class="ident">CounterType</span> <span class="ident">val</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typename</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">CounterType</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">const_iterator</span> <span class="ident">cit</span> <span class="op">=</span> <span class="ident">cntVec</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">cit</span> <span class="op">!=</span> <span class="ident">cntVec</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>  <span class="op">++</span><span class="ident">cit</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="op">*</span><span class="ident">cit</span><span class="op">!=</span><span class="ident">val</span><span class="round">)</span>
            <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Удаление внешних скобок с учетом вложенности внутренних</span>
<span class="cmnt">/*! \returns Разбитый по скобкам набор строк */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span>
<span class="ident">simple_unbrace</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>                          <span class="cmnt">//!&lt; Строка со скобками</span>
              <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">braces</span>                       <span class="cmnt">//!&lt; Список допустимых/скобок</span>
              <span class="op">,</span> <span class="kwd1">bool</span>              <span class="ident">keepStartingBrace</span> <span class="op">=</span> <span class="kwd1">false</span>    <span class="cmnt">//!&lt; Оставить ли открывающую скобку (как маркер)</span>
              <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">CharType</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">res</span><span class="op">;</span>

    <span class="ident">StringType</span> <span class="ident">leftBraces</span><span class="op">,</span> <span class="ident">rightBraces</span><span class="op">;</span>
    <span class="ident">build_pairs</span><span class="round">(</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">leftBraces</span><span class="op">,</span> <span class="ident">rightBraces</span> <span class="round">)</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="ident">CharType</span> <span class="op">&gt;</span> <span class="ident">bracesStack</span><span class="op">;</span>
    <span class="cmnt">//bracesStack.reserve(8);</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="kwd1">int</span><span class="op">&gt;</span> <span class="ident">nestingCounts</span><span class="round">(</span> <span class="ident">leftBraces</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="num">0</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">startPos</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">pos</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">while</span><span class="round">(</span><span class="ident">pos</span><span class="op">!=</span><span class="ident">size</span><span class="round">)</span> <span class="cmnt">// ; ++pos</span>
    <span class="curly">{</span>
        <span class="ident">CharType</span> <span class="ident">ch</span> <span class="op">=</span> <span class="ident">str</span><span class="square">[</span><span class="ident">pos</span><span class="square">]</span><span class="op">;</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">lIdx</span> <span class="op">=</span> <span class="ident">leftBraces</span> <span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">rIdx</span> <span class="op">=</span> <span class="ident">rightBraces</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">lIdx</span><span class="op">==</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">rIdx</span><span class="op">==</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="op">++</span><span class="ident">pos</span><span class="op">;</span>
            <span class="kwd1">continue</span><span class="op">;</span> <span class="cmnt">// not an opening or closing brace</span>
        <span class="curly">}</span>

        <span class="cmnt">// Found opening or closing brace</span>
        <span class="kwd1">bool</span> <span class="ident">nonPairedBraceOpen</span> <span class="op">=</span> <span class="kwd1">true</span><span class="op">;</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">lIdx</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">rIdx</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">bracesStack</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span> <span class="op">&amp;&amp;</span> <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">back</span><span class="round">(</span><span class="round">)</span><span class="op">==</span><span class="ident">ch</span><span class="round">)</span>
                <span class="ident">nonPairedBraceOpen</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>
        <span class="curly">}</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">lIdx</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">nonPairedBraceOpen</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="cmnt">// Opening brace</span>
            <span class="kwd1">bool</span> <span class="ident">pushedVal</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">startPos</span><span class="op">!=</span><span class="ident">pos</span> <span class="cmnt">/*&amp;&amp; util_check_all_exact( nestingCounts, 0 )*/</span> <span class="op">&amp;&amp;</span> <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">startPos</span><span class="op">,</span> <span class="ident">pos</span><span class="op">-</span><span class="ident">startPos</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
                <span class="ident">pushedVal</span> <span class="op">=</span> <span class="kwd1">true</span><span class="op">;</span>
            <span class="curly">}</span>

            <span class="ident">nestingCounts</span><span class="square">[</span><span class="ident">lIdx</span><span class="square">]</span><span class="op">++</span><span class="op">;</span>
            <span class="op">++</span><span class="ident">pos</span><span class="op">;</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">pushedVal</span><span class="round">)</span>
                <span class="ident">startPos</span> <span class="op">=</span> <span class="ident">pos</span><span class="op">;</span>

            <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>

            <span class="kwd1">continue</span><span class="op">;</span>
        <span class="curly">}</span>

        <span class="cmnt">// Only closing brace here</span>

        <span class="op">++</span><span class="ident">pos</span><span class="op">;</span>
        <span class="ident">nestingCounts</span><span class="square">[</span><span class="ident">rIdx</span><span class="square">]</span><span class="op">--</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">bracesStack</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
            <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">pop_back</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>

        <span class="cmnt">//if (util_check_all_exact( nestingCounts, 0 ))</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">bracesStack</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">keepStartingBrace</span><span class="round">)</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">startPos</span><span class="op">-</span><span class="num">1</span><span class="op">,</span> <span class="ident">pos</span><span class="op">-</span><span class="ident">startPos</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
            <span class="kwd1">else</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">startPos</span><span class="op">,</span> <span class="ident">pos</span><span class="op">-</span><span class="ident">startPos</span><span class="op">-</span><span class="num">1</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
            <span class="ident">startPos</span> <span class="op">=</span> <span class="ident">pos</span><span class="op">;</span>
        <span class="curly">}</span>
    <span class="curly">}</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">startPos</span><span class="op">!=</span><span class="ident">pos</span><span class="round">)</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">startPos</span><span class="op">,</span> <span class="ident">pos</span><span class="op">-</span><span class="ident">startPos</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Удаление внешних скобок с учетом вложенности внутренних</span>
<span class="cmnt">/*! \returns Разбитый по скобкам набор строк */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span>
<span class="ident">simple_unbrace</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>                          <span class="cmnt">//!&lt; Строка со скобками</span>
              <span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">braces</span>  <span class="cmnt">//!&lt; Список допустимых/скобок</span>
              <span class="op">,</span> <span class="kwd1">bool</span>              <span class="ident">keepStartingBrace</span> <span class="op">=</span> <span class="kwd1">false</span>    <span class="cmnt">//!&lt; Оставить ли открывающую скобку (как маркер)</span>
              <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">simple_unbrace</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">braces</span><span class="round">)</span><span class="op">,</span> <span class="ident">keepStartingBrace</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>


<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Утилита для разбора строк по скобкам</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">split_against_braces_helper</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="ident">std</span><span class="op">::</span><span class="ident">pair</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span><span class="op">&gt;</span> <span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">nonBraceRanges</span> <span class="cmnt">//!&lt; [out] Не заскобыченные диапазоны</span>
                                       <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">str</span>                                                                       <span class="cmnt">//!&lt; Входная строка</span>
                                       <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">braces</span>                                                                    <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                                       <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span>       <span class="op">&amp;</span><span class="ident">fileName</span> <span class="op">=</span> <span class="ident">make_string</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="str">&quot;&quot;</span><span class="round">)</span>                                    <span class="cmnt">//!&lt; Имя файла?</span>
                                       <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>                                                                     <span class="cmnt">//!&lt; Номер строки</span>
                                       <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>                                                                        <span class="cmnt">//!&lt; Позиция в строке</span>
                                       <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>                                                                           <span class="cmnt">//!&lt; Строгий порядок?</span>
                                       <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">CharType</span><span class="op">;</span>

    <span class="ident">StringType</span> <span class="ident">leftBraces</span><span class="op">,</span> <span class="ident">rightBraces</span><span class="op">;</span>
    <span class="ident">build_pairs</span><span class="round">(</span> <span class="ident">braces</span><span class="op">,</span> <span class="op">&amp;</span><span class="ident">leftBraces</span><span class="op">,</span> <span class="op">&amp;</span><span class="ident">rightBraces</span> <span class="round">)</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="ident">CharType</span> <span class="op">&gt;</span> <span class="ident">bracesStack</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="kwd1">int</span><span class="op">&gt;</span> <span class="ident">nestingCounts</span><span class="round">(</span> <span class="ident">leftBraces</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="num">0</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">startPos</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">pos</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">while</span><span class="round">(</span><span class="ident">pos</span><span class="op">!=</span><span class="ident">size</span><span class="round">)</span> <span class="cmnt">// ; ++pos</span>
    <span class="curly">{</span>
        <span class="cmnt">// Not in braces</span>
        <span class="ident">CharType</span> <span class="ident">ch</span> <span class="op">=</span> <span class="ident">str</span><span class="square">[</span><span class="ident">pos</span><span class="square">]</span><span class="op">;</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">lIdx</span> <span class="op">=</span> <span class="ident">leftBraces</span> <span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">rIdx</span> <span class="op">=</span> <span class="ident">rightBraces</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">ch</span> <span class="round">)</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">lIdx</span><span class="op">==</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">rIdx</span><span class="op">==</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="op">++</span><span class="ident">pos</span><span class="op">;</span>
            <span class="kwd1">continue</span><span class="op">;</span> <span class="cmnt">// not an opening or closing brace</span>
        <span class="curly">}</span>

        <span class="cmnt">// Found opening or closing brace</span>
        <span class="kwd1">bool</span> <span class="ident">nonPairedBraceOpen</span> <span class="op">=</span> <span class="kwd1">true</span><span class="op">;</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">lIdx</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">rIdx</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">strictOrder</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">bracesStack</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span> <span class="op">&amp;&amp;</span> <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">back</span><span class="round">(</span><span class="round">)</span><span class="op">==</span><span class="ident">ch</span><span class="round">)</span>
                    <span class="ident">nonPairedBraceOpen</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>
                <span class="cmnt">//bracesStack.push_back(ch);</span>
            <span class="curly">}</span>
            <span class="kwd1">else</span>
            <span class="curly">{</span>
                <span class="kwd1">if</span> <span class="round">(</span><span class="ident">nestingCounts</span><span class="square">[</span><span class="ident">lIdx</span><span class="square">]</span><span class="op">&gt;</span><span class="num">0</span><span class="round">)</span>
                    <span class="ident">nonPairedBraceOpen</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>
            <span class="curly">}</span>
        <span class="curly">}</span>


        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">lIdx</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">nonPairedBraceOpen</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="cmnt">// Opening brace</span>

            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">strictOrder</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
            <span class="curly">}</span>

            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">startPos</span><span class="op">!=</span><span class="ident">pos</span> <span class="op">&amp;&amp;</span> <span class="ident">util_check_all_exact</span><span class="round">(</span> <span class="ident">nestingCounts</span><span class="op">,</span> <span class="num">0</span> <span class="round">)</span><span class="round">)</span>
                <span class="ident">nonBraceRanges</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">make_pair</span><span class="round">(</span><span class="ident">startPos</span><span class="op">,</span><span class="ident">pos</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>

            <span class="ident">nestingCounts</span><span class="square">[</span><span class="ident">lIdx</span><span class="square">]</span><span class="op">++</span><span class="op">;</span>

            <span class="op">++</span><span class="ident">pos</span><span class="op">;</span>
            <span class="kwd1">continue</span><span class="op">;</span>
        <span class="curly">}</span>

        <span class="cmnt">// Only closing brace here</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">strictOrder</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="cmnt">//bracesStack.push_back(ch);</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">bracesStack</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="kwd1">throw</span> <span class="ident">umba</span><span class="op">::</span><span class="ident">FileParsingException</span><span class="round">(</span><span class="str">&quot;Found closing brace, but there is no opening brace found before&quot;</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="round">)</span><span class="op">;</span>
            <span class="curly">}</span>

            <span class="ident">CharType</span> <span class="ident">openingBrace</span> <span class="op">=</span> <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">back</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
            <span class="ident">bracesStack</span><span class="op">.</span><span class="ident">pop_back</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>

            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">get_pair</span><span class="round">(</span><span class="ident">openingBrace</span><span class="round">)</span><span class="op">!=</span><span class="ident">ch</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="kwd1">throw</span> <span class="ident">umba</span><span class="op">::</span><span class="ident">FileParsingException</span><span class="round">(</span><span class="str">&quot;Opening brace doesn&apos;t match closing brace&quot;</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="round">)</span><span class="op">;</span>
            <span class="curly">}</span>
        <span class="curly">}</span>

        <span class="op">++</span><span class="ident">pos</span><span class="op">;</span>
        <span class="ident">nestingCounts</span><span class="square">[</span><span class="ident">rIdx</span><span class="square">]</span><span class="op">--</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">util_check_all_exact</span><span class="round">(</span> <span class="ident">nestingCounts</span><span class="op">,</span> <span class="num">0</span> <span class="round">)</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="cmnt">// Not not in braces</span>
            <span class="ident">startPos</span> <span class="op">=</span> <span class="ident">pos</span><span class="op">;</span>
        <span class="curly">}</span>
    <span class="curly">}</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">startPos</span><span class="op">!=</span><span class="ident">pos</span><span class="round">)</span>
        <span class="ident">nonBraceRanges</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">make_pair</span><span class="round">(</span><span class="ident">startPos</span><span class="op">,</span><span class="ident">pos</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Возвращает размер входного разделителя</span>
<span class="kwd1">inline</span> <span class="ident">size_t</span> <span class="ident">util_get_sep_size</span><span class="round">(</span><span class="kwd1">const</span> <span class="kwd1">char</span><span class="op">&amp;</span> <span class="ident">sep</span><span class="round">)</span>           <span class="curly">{</span> <span class="ident">UMBA_USED</span><span class="round">(</span><span class="ident">sep</span><span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="num">1</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает размер входного разделителя</span>
<span class="kwd1">inline</span> <span class="ident">size_t</span> <span class="ident">util_get_sep_size</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">&amp;</span><span class="ident">sep</span> <span class="round">)</span>      <span class="curly">{</span> <span class="ident">UMBA_USED</span><span class="round">(</span><span class="ident">sep</span><span class="round">)</span><span class="op">;</span> <span class="kwd1">return</span> <span class="num">1</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает размер входного разделителя</span>
<span class="kwd1">inline</span> <span class="ident">size_t</span> <span class="ident">util_get_sep_size</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">char</span> <span class="op">*</span><span class="ident">sep</span> <span class="round">)</span>         <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">std</span><span class="op">::</span><span class="ident">strlen</span><span class="round">(</span><span class="ident">sep</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает размер входного разделителя</span>
<span class="kwd1">inline</span> <span class="ident">size_t</span> <span class="ident">util_get_sep_size</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">sep</span> <span class="round">)</span>      <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wcslen</span><span class="round">(</span><span class="ident">sep</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает размер входного разделителя</span>
<span class="kwd1">inline</span> <span class="ident">size_t</span> <span class="ident">util_get_sep_size</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="op">&amp;</span><span class="ident">sep</span> <span class="round">)</span>  <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">sep</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>
<span class="cmnt">//! Возвращает размер входного разделителя</span>
<span class="kwd1">inline</span> <span class="ident">size_t</span> <span class="ident">util_get_sep_size</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="op">&amp;</span><span class="ident">sep</span> <span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">sep</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Какой-то хелпер</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">SepType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="op">&gt;</span>
<span class="ident">split_against_braces_get_sep_positions</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span>   <span class="op">&amp;</span><span class="ident">str</span>    <span class="cmnt">//!&lt; Входная строка</span>
                               <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>         <span class="op">&amp;</span><span class="ident">braces</span>  <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                               <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">SepType</span>            <span class="op">&amp;</span><span class="ident">sep</span>     <span class="cmnt">//!&lt; Разделитель</span>
                               <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&amp;</span> <span class="ident">fileName</span> <span class="op">=</span> <span class="str">&quot;&quot;</span>  <span class="cmnt">//!&lt; Имя файла?</span>
                               <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>    <span class="cmnt">//!&lt; Номер строки</span>
                               <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>       <span class="cmnt">//!&lt; Позиция в строке</span>
                               <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>          <span class="cmnt">//!&lt; Строгий порядок?</span>
                               <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="ident">std</span><span class="op">::</span><span class="ident">pair</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span><span class="op">&gt;</span> <span class="op">&gt;</span> <span class="ident">nonBraceRanges</span><span class="op">;</span>
    <span class="ident">split_against_braces_helper</span><span class="round">(</span> <span class="ident">nonBraceRanges</span><span class="op">,</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="op">,</span> <span class="ident">strictOrder</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">sepSize</span> <span class="op">=</span> <span class="ident">util_get_sep_size</span><span class="round">(</span><span class="ident">sep</span><span class="round">)</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="op">&gt;</span> <span class="ident">sepPositions</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="ident">std</span><span class="op">::</span><span class="ident">pair</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span><span class="op">&gt;</span> <span class="op">&gt;</span><span class="op">::</span><span class="ident">const_iterator</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">nonBraceRanges</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">it</span> <span class="op">!=</span> <span class="ident">nonBraceRanges</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="op">++</span><span class="ident">it</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">beginPos</span> <span class="op">=</span> <span class="ident">it</span><span class="op">-&gt;</span><span class="ident">first</span><span class="op">;</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">endPos</span>   <span class="op">=</span> <span class="ident">it</span><span class="op">-&gt;</span><span class="ident">second</span><span class="op">;</span>

        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">sepPos</span>   <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">beginPos</span> <span class="round">)</span><span class="op">;</span>
        <span class="kwd1">while</span><span class="round">(</span><span class="ident">sepPos</span><span class="op">!=</span><span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="op">&amp;&amp;</span> <span class="ident">sepPos</span><span class="op">&lt;</span><span class="ident">endPos</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="ident">sepPositions</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span><span class="ident">sepPos</span><span class="round">)</span><span class="op">;</span>
            <span class="ident">beginPos</span> <span class="op">=</span> <span class="ident">sepPos</span> <span class="op">+</span> <span class="ident">sepSize</span><span class="op">;</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">beginPos</span><span class="op">&gt;=</span><span class="ident">endPos</span><span class="round">)</span>
                <span class="kwd1">break</span><span class="op">;</span>
            <span class="ident">sepPos</span>   <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">beginPos</span> <span class="round">)</span><span class="op">;</span>
        <span class="curly">}</span>
    <span class="curly">}</span>

    <span class="kwd1">return</span> <span class="ident">sepPositions</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Какая-то реализация</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">SepType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">split_against_braces_impl</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">splits</span>   <span class="cmnt">//!&lt; [out] Какой-то выхлоп</span>
                              <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">str</span>      <span class="cmnt">//!&lt; Входная строка</span>
                              <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">braces</span>   <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                              <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">SepType</span>            <span class="op">&amp;</span><span class="ident">sep</span>     <span class="cmnt">//!&lt; Разделитель</span>
                              <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&amp;</span> <span class="ident">fileName</span> <span class="op">=</span> <span class="str">&quot;&quot;</span>  <span class="cmnt">//!&lt; Имя файла?</span>
                              <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>    <span class="cmnt">//!&lt; Номер строки</span>
                              <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>       <span class="cmnt">//!&lt; Позиция в строке</span>
                              <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>          <span class="cmnt">//!&lt; Строгий порядок?</span>
                              <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">sepSize</span> <span class="op">=</span> <span class="ident">util_get_sep_size</span><span class="round">(</span><span class="ident">sep</span><span class="round">)</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="op">&gt;</span> <span class="ident">sepPositions</span> <span class="op">=</span>
        <span class="ident">split_against_braces_get_sep_positions</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="op">,</span> <span class="ident">strictOrder</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">sepPositions</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">splits</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">str</span> <span class="round">)</span><span class="op">;</span>
        <span class="kwd1">return</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">startPos</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">sepPos</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">typename</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="op">&gt;</span><span class="op">::</span><span class="ident">const_iterator</span> <span class="ident">sepPosIt</span> <span class="op">=</span> <span class="ident">sepPositions</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">sepPosIt</span><span class="op">!=</span><span class="ident">sepPositions</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span> <span class="op">&amp;&amp;</span> <span class="ident">startPos</span><span class="op">&lt;</span><span class="ident">size</span><span class="op">;</span> <span class="op">++</span><span class="ident">sepPosIt</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">sepPos</span> <span class="op">=</span> <span class="op">*</span><span class="ident">sepPosIt</span><span class="op">;</span>
        <span class="ident">splits</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">StringType</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">startPos</span><span class="op">,</span> <span class="ident">sepPos</span><span class="op">-</span><span class="ident">startPos</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
        <span class="ident">startPos</span> <span class="op">=</span> <span class="ident">sepPos</span> <span class="op">+</span> <span class="ident">sepSize</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="cmnt">//if ((sepPos))</span>
    <span class="cmnt">//if (startPos&lt;size )</span>
    <span class="curly">{</span>
        <span class="ident">splits</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">StringType</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">startPos</span><span class="op">,</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span> <span class="round">)</span> <span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Сплит строки по разделителю с учетом скобок</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">split_against_braces</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">splits</span>      <span class="cmnt">//!&lt; [out] Выхлоп</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">str</span>         <span class="cmnt">//!&lt; Входная строка</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">braces</span>      <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                         <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">sep</span>  <span class="cmnt">//!&lt; Разделитель</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&amp;</span> <span class="ident">fileName</span> <span class="op">=</span> <span class="str">&quot;&quot;</span>     <span class="cmnt">//!&lt; Имя файла?</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>       <span class="cmnt">//!&lt; Номер строки</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>          <span class="cmnt">//!&lt; Позиция в строке</span>
                         <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>             <span class="cmnt">//!&lt; Строгий порядок?</span>
                         <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">split_against_braces_impl</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">splits</span><span class="op">,</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="op">,</span> <span class="ident">strictOrder</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Сплит строки по разделителю с учетом скобок</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">split_against_braces</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span>                <span class="op">&amp;</span><span class="ident">splits</span>  <span class="cmnt">//!&lt; [out] Выхлоп</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>                       <span class="op">&amp;</span><span class="ident">str</span>     <span class="cmnt">//!&lt; Входная строка</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span>  <span class="op">*</span><span class="ident">braces</span>  <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                         <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span>         <span class="ident">sep</span>     <span class="cmnt">//!&lt; Разделитель</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&amp;</span> <span class="ident">fileName</span> <span class="op">=</span> <span class="str">&quot;&quot;</span>                <span class="cmnt">//!&lt; Имя файла?</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>                  <span class="cmnt">//!&lt; Номер строки</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>                     <span class="cmnt">//!&lt; Позиция в строке</span>
                         <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>                        <span class="cmnt">//!&lt; Строгий порядок?</span>
                         <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">split_against_braces_impl</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">splits</span><span class="op">,</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="op">,</span> <span class="ident">strictOrder</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Сплит строки по разделителю с учетом скобок</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">split_against_braces</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">splits</span>   <span class="cmnt">//!&lt; [out] Выхлоп</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">str</span>      <span class="cmnt">//!&lt; Входная строка</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">braces</span>   <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>        <span class="op">&amp;</span><span class="ident">sep</span>      <span class="cmnt">//!&lt; Разделитель</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&amp;</span> <span class="ident">fileName</span> <span class="op">=</span> <span class="str">&quot;&quot;</span>  <span class="cmnt">//!&lt; Имя файла?</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>    <span class="cmnt">//!&lt; Номер строки</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>       <span class="cmnt">//!&lt; Позиция в строке</span>
                         <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>          <span class="cmnt">//!&lt; Строгий порядок?</span>
                         <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">split_against_braces_impl</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">,</span> <span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">splits</span><span class="op">,</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="op">,</span> <span class="ident">strictOrder</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Сплит строки по разделителю с учетом скобок</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">split_against_braces</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span>               <span class="op">&amp;</span><span class="ident">splits</span>  <span class="cmnt">//!&lt; [out] Выхлоп</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>                      <span class="op">&amp;</span><span class="ident">str</span>     <span class="cmnt">//!&lt; Входная строка</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">braces</span>  <span class="cmnt">//!&lt; Обрабатываемые скобки</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span>                       <span class="op">&amp;</span><span class="ident">sep</span>    <span class="cmnt">//!&lt; Разделитель</span>
                         <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&amp;</span> <span class="ident">fileName</span> <span class="op">=</span> <span class="str">&quot;&quot;</span>               <span class="cmnt">//!&lt; Имя файла?</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">lineNumber</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>                 <span class="cmnt">//!&lt; Номер строки</span>
                         <span class="op">,</span> <span class="ident">size_t</span> <span class="ident">linePos</span> <span class="op">=</span> <span class="round">(</span><span class="ident">size_t</span><span class="round">)</span><span class="op">-</span><span class="num">1</span>                    <span class="cmnt">//!&lt; Позиция в строке</span>
                         <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">strictOrder</span> <span class="op">=</span> <span class="kwd1">false</span>                       <span class="cmnt">//!&lt; Строгий порядок?</span>
                         <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">split_against_braces_impl</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">,</span> <span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span> <span class="ident">splits</span><span class="op">,</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">braces</span><span class="op">,</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">fileName</span><span class="op">,</span> <span class="ident">lineNumber</span><span class="op">,</span> <span class="ident">linePos</span><span class="op">,</span> <span class="ident">strictOrder</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>


<span class="cmnt">//------------------------------</span>

<span class="curly">}</span> <span class="cmnt">// ascii_brace</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>





<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Удаление пустых элементов</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">eraseEmptiesHelper</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="ident">v</span> <span class="cmnt">/*!&lt; Вектор элементов */</span><span class="round">)</span>
<span class="curly">{</span>

    <span class="cmnt">// Чукич, стр 62</span>
    <span class="pp">#<span class="ident">ifdef</span> <span class="ident">UMBA_CXX_HAS_STD11</span>
</span>
    <span class="cmnt">// В 2005 студии оно не работает</span>
    <span class="kwd1">typename</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">iterator</span> <span class="ident">rmIt</span> <span class="op">=</span> <span class="ident">std</span><span class="op">::</span><span class="ident">remove_if</span><span class="round">(</span><span class="ident">v</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">v</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="square">[</span><span class="square">]</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">StringType</span><span class="op">&amp;</span> <span class="ident">s</span><span class="round">)</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">s</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="op">;</span> <span class="curly">}</span><span class="round">)</span><span class="op">;</span>
    <span class="cmnt">//if (rmIt!=v.end())</span>
    <span class="ident">v</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span><span class="ident">rmIt</span><span class="op">,</span> <span class="ident">v</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>

    <span class="pp">#<span class="ident">else</span>
</span>
    <span class="kwd1">typename</span> <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">iterator</span> <span class="ident">rmIt</span> <span class="op">=</span> <span class="ident">std</span><span class="op">::</span><span class="ident">remove_if</span><span class="round">(</span> <span class="ident">v</span><span class="op">.</span><span class="ident">begin</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">v</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">lambda_is_empty</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
    <span class="cmnt">//if (rmIt!=)</span>
    <span class="ident">v</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span><span class="ident">rmIt</span><span class="op">,</span> <span class="ident">v</span><span class="op">.</span><span class="ident">end</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>

    <span class="pp">#<span class="ident">endif</span>
</span><span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Тупой сплит строки, используется версия сплита по скобкам с редуцированным набором скобок</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">split</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>                  <span class="cmnt">//!&lt; Входная строка</span>
                             <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">delim</span>  <span class="cmnt">//!&lt; Разделитель</span>
                             <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">skipEmpty</span> <span class="op">=</span> <span class="kwd1">true</span>                  <span class="cmnt">//!&lt; Пропускать пустые элементы?</span>
                             <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">splits</span><span class="op">;</span>
    <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">split_against_braces</span><span class="round">(</span> <span class="ident">splits</span><span class="op">,</span> <span class="ident">str</span>
                                     <span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="round">)</span> <span class="cmnt">// no braces at all</span>
                                     <span class="op">,</span> <span class="ident">delim</span>
                                     <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">skipEmpty</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="cmnt">// Чукич, стр 62</span>
        <span class="cmnt">// #if 0 // В 2005 студии оно не работает</span>
        <span class="cmnt">// eraseEmptiesHelper( splits );</span>
        <span class="cmnt">// #endif</span>
        <span class="ident">eraseEmptiesHelper</span><span class="round">(</span> <span class="ident">splits</span> <span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">return</span> <span class="ident">splits</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//------------------------------</span>
<span class="cmnt">//! Тупой сплит строки, используется версия сплита по скобкам с редуцированным набором скобок</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">split</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>    <span class="cmnt">//!&lt; Входная строка</span>
                             <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">delim</span>  <span class="cmnt">//!&lt; Разделитель</span>
                             <span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">skipEmpty</span> <span class="op">=</span> <span class="kwd1">true</span>    <span class="cmnt">//!&lt; Пропускать пустые элементы?</span>
                             <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">splits</span><span class="op">;</span>
    <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">split_against_braces</span><span class="round">(</span> <span class="ident">splits</span><span class="op">,</span> <span class="ident">str</span>
                                     <span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="round">)</span> <span class="cmnt">// no braces at all</span>
                                     <span class="op">,</span> <span class="ident">delim</span>
                                     <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">skipEmpty</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="cmnt">// Чукич, стр 62</span>
        <span class="cmnt">// #if 0 // В 2005 студии оно не работает</span>
        <span class="cmnt">// splits.erase( std::remove_if( splits.begin()</span>
        <span class="cmnt">//                             , splits.end()</span>
        <span class="cmnt">//                             #ifdef UMBA_CXX_HAS_STD11</span>
        <span class="cmnt">//                             , []( const StringType &amp;s) { return s.empty(); }</span>
        <span class="cmnt">//                             #else</span>
        <span class="cmnt">//                             , lambda_is_empty&lt;StringType&gt;()</span>
        <span class="cmnt">//                             #endif</span>
        <span class="cmnt">//                             )</span>
        <span class="cmnt">//             );</span>
        <span class="cmnt">// #endif</span>
        <span class="ident">eraseEmptiesHelper</span><span class="round">(</span> <span class="ident">splits</span> <span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">return</span> <span class="ident">splits</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Сплит строки по классу символа</span>
<span class="cmnt">/*! Хз, что, где-то было нужно
    \note https://stackoverflow.com/questions/257288/templated-check-for-the-existence-of-a-class-member-function
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">CharClassBoolPred</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">CharClassType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">split_by_class</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>          <span class="cmnt">//!&lt; Входная строка</span>
                                      <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">CharClassBoolPred</span> <span class="op">&amp;</span><span class="ident">pred</span>  <span class="cmnt">//!&lt; Предикат класса символа</span>
                                      <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">res</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>

    <span class="ident">res</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">StringType</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">CharClassType</span> <span class="ident">prevCharClass</span> <span class="op">=</span> <span class="ident">pred</span><span class="round">(</span><span class="ident">str</span><span class="square">[</span><span class="num">0</span><span class="square">]</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">i</span> <span class="op">=</span> <span class="num">0</span><span class="op">,</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">for</span><span class="round">(</span><span class="op">;</span> <span class="ident">i</span><span class="op">!=</span><span class="ident">size</span><span class="op">;</span> <span class="op">++</span><span class="ident">i</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">ch</span> <span class="op">=</span> <span class="ident">str</span><span class="square">[</span><span class="ident">i</span><span class="square">]</span><span class="op">;</span>
        <span class="ident">CharClassType</span> <span class="ident">curCharClass</span> <span class="op">=</span> <span class="ident">pred</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">prevCharClass</span><span class="op">!=</span><span class="ident">curCharClass</span><span class="round">)</span>
            <span class="ident">res</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span><span class="op">;</span>
        <span class="ident">prevCharClass</span> <span class="op">=</span> <span class="ident">curCharClass</span><span class="op">;</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">back</span><span class="round">(</span><span class="round">)</span><span class="op">.</span><span class="ident">push_back</span><span class="round">(</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>

<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Делит строку на две подстроки по сепаратору, возвращает true, если split реально произошел</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">split_to_pair</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">first</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">second</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">sep</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">pos</span> <span class="op">=</span> <span class="num">0</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">auto</span> <span class="ident">fpos</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">pos</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">fpos</span><span class="op">==</span><span class="ident">str</span><span class="op">.</span><span class="ident">npos</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">second</span><span class="op">.</span><span class="ident">clear</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">first</span> <span class="op">=</span> <span class="ident">str</span><span class="op">;</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="ident">first</span>  <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">substr</span><span class="round">(</span> <span class="num">0</span>              <span class="op">,</span> <span class="ident">fpos</span>     <span class="round">)</span><span class="op">;</span>
    <span class="ident">second</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">substr</span><span class="round">(</span> <span class="ident">fpos</span><span class="op">+</span><span class="ident">sep</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">str</span><span class="op">.</span><span class="ident">npos</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>

<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Делит строку на две подстроки по сепаратору, возвращает true, если split реально произошел</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">split_to_pair</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">first</span><span class="op">,</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">second</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">&amp;</span><span class="ident">sep</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">pos</span> <span class="op">=</span> <span class="num">0</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">auto</span> <span class="ident">fpos</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span> <span class="ident">sep</span><span class="op">,</span> <span class="ident">pos</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">fpos</span><span class="op">==</span><span class="ident">str</span><span class="op">.</span><span class="ident">npos</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">second</span><span class="op">.</span><span class="ident">clear</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">first</span> <span class="op">=</span> <span class="ident">str</span><span class="op">;</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="ident">first</span>  <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">substr</span><span class="round">(</span> <span class="num">0</span>     <span class="op">,</span> <span class="ident">fpos</span>     <span class="round">)</span><span class="op">;</span>
    <span class="ident">second</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">substr</span><span class="round">(</span> <span class="ident">fpos</span><span class="op">+</span><span class="num">1</span><span class="op">,</span> <span class="ident">str</span><span class="op">.</span><span class="ident">npos</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>

<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">simple_string_split</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">nSplits</span> <span class="op">=</span> <span class="op">-</span><span class="num">1</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="cmnt">// std::string s = &quot;scott&gt;=tiger&gt;=mushroom&quot;;</span>
    <span class="cmnt">// std::string delimiter = &quot;&gt;=&quot;;</span>

    <span class="cmnt">// txt = &quot;apple#banana#cherry#orange&quot;</span>
    <span class="cmnt">// # setting the maxsplit parameter to 1, will return a list with 2 elements!</span>
    <span class="cmnt">// x = txt.split(&quot;#&quot;, 1)</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">res</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">curPos</span>  <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">prevPos</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
    <span class="cmnt">//StringType token;</span>
    <span class="kwd1">while</span> <span class="round">(</span><span class="ident">res</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">!=</span><span class="ident">nSplits</span> <span class="op">&amp;&amp;</span> <span class="round">(</span><span class="ident">curPos</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span><span class="ident">delim</span><span class="op">,</span> <span class="ident">prevPos</span><span class="round">)</span><span class="round">)</span> <span class="op">!=</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">emplace_back</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">prevPos</span><span class="op">,</span> <span class="ident">curPos</span><span class="op">-</span><span class="ident">prevPos</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">prevPos</span> <span class="op">=</span> <span class="ident">curPos</span><span class="op">+</span><span class="ident">delim</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="cmnt">// Ранее остаток закидывали безусловно</span>
    <span class="cmnt">// Пока так и оставим</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">emplace_back</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">prevPos</span><span class="op">,</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span><span class="op">;</span>

    <span class="cmnt">//TODO: !!! Надо подумать, править баг и как его править</span>
    <span class="pp">#<span class="ident">if</span> <span class="num">0</span>
</span>    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">res</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">==</span><span class="ident">nSplits</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="cmnt">// Набрали нужное количество частей, надо закинуть последнюю без всяких условий</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">emplace_back</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">prevPos</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">else</span>
    <span class="curly">{</span>
        <span class="cmnt">// У нас сплит до упора, и мы просто не нашли следующий разделитель после последнего его вхождения</span>
        <span class="cmnt">// Или мы вообще его не нашли</span>
        <span class="cmnt">// Или мы его вообще не нашли</span>
        <span class="cmnt">// Что и где может поломаться, если мы что-то тут подправим?</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="round">)</span>
    <span class="curly">}</span>
    <span class="pp">#<span class="ident">endif</span>
</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">simple_string_split</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">nSplits</span> <span class="op">=</span> <span class="op">-</span><span class="num">1</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">simple_string_split</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">delim</span><span class="round">)</span><span class="op">,</span> <span class="ident">nSplits</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">vector</span><span class="op">&lt;</span><span class="ident">StringType</span><span class="op">&gt;</span> <span class="ident">simple_string_split</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">delim</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">nSplits</span> <span class="op">=</span> <span class="op">-</span><span class="num">1</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">tmpDelimStr</span><span class="square">[</span><span class="num">2</span><span class="square">]</span> <span class="op">=</span> <span class="curly">{</span> <span class="ident">delim</span><span class="op">,</span> <span class="num">0</span> <span class="curly">}</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">simple_string_split</span><span class="round">(</span> <span class="ident">str</span><span class="op">,</span> <span class="ident">tmpDelimStr</span><span class="op">,</span> <span class="ident">nSplits</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">OutputIterator</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">void</span> <span class="ident">simple_string_split</span><span class="round">(</span><span class="ident">OutputIterator</span> <span class="ident">inserterIt</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">delim</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">nSplits</span> <span class="op">=</span> <span class="op">-</span><span class="num">1</span><span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">curPos</span>  <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">prevPos</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">numPartsAdded</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>

    <span class="cmnt">//StringType token;</span>
    <span class="kwd1">while</span> <span class="round">(</span><span class="ident">numPartsAdded</span><span class="op">!=</span><span class="ident">nSplits</span> <span class="op">&amp;&amp;</span> <span class="round">(</span><span class="ident">curPos</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">find</span><span class="round">(</span><span class="ident">delim</span><span class="op">,</span> <span class="ident">prevPos</span><span class="round">)</span><span class="round">)</span> <span class="op">!=</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="op">*</span><span class="ident">inserterIt</span><span class="op">++</span> <span class="op">=</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">prevPos</span><span class="op">,</span> <span class="ident">curPos</span><span class="op">-</span><span class="ident">prevPos</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">prevPos</span> <span class="op">=</span> <span class="ident">curPos</span><span class="op">+</span><span class="ident">delim</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
        <span class="op">++</span><span class="ident">numPartsAdded</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="cmnt">// Ранее остаток закидывали безусловно</span>
    <span class="cmnt">// Пока так и оставим</span>
    <span class="op">*</span><span class="ident">inserterIt</span><span class="op">++</span> <span class="op">=</span> <span class="ident">StringType</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">prevPos</span><span class="op">,</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">npos</span><span class="round">)</span><span class="op">;</span>

    <span class="cmnt">//TODO: !!! Надо подумать, править баг и как его править</span>
    <span class="pp">#<span class="ident">if</span> <span class="num">0</span>
</span>    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">res</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">==</span><span class="ident">nSplits</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="cmnt">// Набрали нужное количество частей, надо закинуть последнюю без всяких условий</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">emplace_back</span><span class="round">(</span><span class="ident">str</span><span class="op">,</span> <span class="ident">prevPos</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">else</span>
    <span class="curly">{</span>
        <span class="cmnt">// У нас сплит до упора, и мы просто не нашли следующий разделитель после последнего его вхождения</span>
        <span class="cmnt">// Или мы вообще его не нашли</span>
        <span class="cmnt">// Или мы его вообще не нашли</span>
        <span class="cmnt">// Что и где может поломаться, если мы что-то тут подправим?</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="round">)</span>
    <span class="curly">}</span>
    <span class="pp">#<span class="ident">endif</span>
</span>
    <span class="cmnt">//return res;</span>
<span class="curly">}</span>


<span class="cmnt">// bool splitToPair( std::string str, std::string &amp;first, std::string &amp;second, char ch, std::string::size_type pos = 0 )</span>

<span class="cmnt">// bool hasEq = splitToPair(cmdLineArg, opt, optArg, &apos;=&apos;);</span>


<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка закавычена.</span>
<span class="cmnt">/*!
    Если quotEnd не равен нулю, то кавычки используются как задано, иначе - автоопределение.
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">is_quoted</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span>                        <span class="cmnt">//!&lt; Строка для проверки</span>
              <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotStart</span>    <span class="cmnt">//!&lt; Открывающая кавычка</span>
              <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotEnd</span> <span class="op">=</span> <span class="num">0</span>  <span class="cmnt">//!&lt; Закрывающая кавычка, если 0 - то срабатывает автоопределение обоих кавычек (используются парные символы по открывающией кавычке)</span>
              <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">s</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">&lt;</span><span class="num">2</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">quotEnd</span><span class="op">==</span><span class="num">0</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">quotEnd</span>   <span class="op">=</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_right</span><span class="round">(</span><span class="ident">quotStart</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">quotStart</span> <span class="op">=</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_left</span><span class="round">(</span><span class="ident">quotStart</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">s</span><span class="square">[</span><span class="num">0</span><span class="square">]</span><span class="op">==</span><span class="ident">quotStart</span> <span class="op">&amp;&amp;</span> <span class="ident">s</span><span class="square">[</span><span class="ident">s</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">-</span><span class="num">1</span><span class="square">]</span><span class="op">==</span><span class="ident">quotEnd</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает раскавыченную строку</span>
<span class="cmnt">/*!
    Строка заключена в одинаковые символы кавычек, внутри они дублируются
    Используется в bat-файлах, и тп
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">unquoteSimpleQuoted</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span> <span class="cmnt">//!&lt; Строка для раскавычивания</span>
                        <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">&lt;</span><span class="num">2</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="ident">str</span><span class="op">;</span>

    <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotChar</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">front</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">str</span><span class="op">.</span><span class="ident">front</span><span class="round">(</span><span class="round">)</span><span class="op">!=</span><span class="ident">quotChar</span> <span class="op">||</span> <span class="ident">str</span><span class="op">.</span><span class="ident">back</span><span class="round">(</span><span class="round">)</span><span class="op">!=</span><span class="ident">quotChar</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="ident">str</span><span class="op">;</span>

    <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">size_type</span> <span class="ident">pos</span> <span class="op">=</span> <span class="num">1</span><span class="op">,</span> <span class="ident">endPos</span> <span class="op">=</span> <span class="ident">str</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">-</span><span class="num">1</span><span class="op">;</span>

    <span class="ident">StringType</span> <span class="ident">res</span><span class="op">;</span> <span class="ident">res</span><span class="op">.</span><span class="ident">reserve</span><span class="round">(</span><span class="ident">endPos</span><span class="op">-</span><span class="ident">pos</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">bool</span> <span class="ident">prevQuot</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">for</span><span class="round">(</span> <span class="op">;</span> <span class="ident">pos</span><span class="op">!=</span><span class="ident">endPos</span><span class="op">;</span> <span class="op">++</span><span class="ident">pos</span> <span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">auto</span> <span class="ident">ch</span> <span class="op">=</span> <span class="ident">str</span><span class="square">[</span><span class="ident">pos</span><span class="square">]</span><span class="op">;</span>

        <span class="kwd1">if</span> <span class="round">(</span><span class="ident">prevQuot</span><span class="round">)</span>
        <span class="curly">{</span>
            <span class="kwd1">if</span> <span class="round">(</span><span class="ident">ch</span><span class="op">==</span><span class="ident">quotChar</span><span class="round">)</span>
            <span class="curly">{</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">quotChar</span><span class="round">)</span><span class="op">;</span> <span class="cmnt">// remove diplicated quots</span>
            <span class="curly">}</span>
            <span class="kwd1">else</span>
            <span class="curly">{</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">quotChar</span><span class="round">)</span><span class="op">;</span>
                <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span> <span class="cmnt">// не знаю, что это, просто игнорим</span>
            <span class="curly">}</span>
            <span class="ident">prevQuot</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>
        <span class="curly">}</span>
        <span class="kwd1">else</span>
        <span class="curly">{</span>
            <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">ch</span><span class="round">)</span><span class="op">;</span>
        <span class="curly">}</span>
    <span class="curly">}</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">prevQuot</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="num">1</span><span class="op">,</span><span class="ident">quotChar</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>

<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка была закавычена, и раскавычивает её.</span>
<span class="cmnt">/*!
    Если quotEnd не равен нулю, то кавычки используются как задано, иначе - автоопределение.
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">unquote</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span>                             <span class="cmnt">//!&lt; Строка для раскавычивания</span>
            <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotStart</span>   <span class="cmnt">//!&lt; Открывающая кавычка</span>
            <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotEnd</span> <span class="op">=</span> <span class="num">0</span> <span class="cmnt">//!&lt; Закрывающая кавычка, если 0 - то срабатывает автоопределение обоих кавычек (используются парные символы по открывающией кавычке)</span>
            <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">is_quoted</span><span class="round">(</span><span class="ident">s</span><span class="op">,</span> <span class="ident">quotStart</span><span class="op">,</span> <span class="ident">quotEnd</span><span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="ident">s</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span> <span class="ident">s</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="op">-</span><span class="num">1</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">s</span><span class="op">.</span><span class="ident">erase</span><span class="round">(</span> <span class="num">0</span><span class="op">,</span> <span class="num">1</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">trim</span><span class="round">(</span><span class="ident">s</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="kwd1">true</span><span class="op">;</span>

<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Возвращает true, если строка была закавычена, и раскавычивает её.</span>
<span class="cmnt">/*!
    Используются первые символы параметров strStart и strEnd. Если quotEnd не равен нулю, то кавычки используются как задано, иначе - автоопределение.
 */</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">unquote</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span>                           <span class="cmnt">//!&lt; Строка для раскавычивания</span>
            <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">strStart</span>              <span class="cmnt">//!&lt; Открывающая кавычка</span>
            <span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">strEnd</span> <span class="op">=</span> <span class="ident">StringType</span><span class="round">(</span><span class="round">)</span> <span class="cmnt">//!&lt; Закрывающая кавычка, если пустая строка - то срабатывает автоопределение обоих кавычек (используются парные символы по открывающией кавычке)</span>
            <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">strStart</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
        <span class="kwd1">return</span> <span class="kwd1">false</span><span class="op">;</span>

    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">strEnd</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
       <span class="kwd1">return</span> <span class="ident">unquote</span><span class="round">(</span> <span class="ident">s</span><span class="op">,</span> <span class="ident">strStart</span><span class="square">[</span><span class="num">0</span><span class="square">]</span><span class="op">,</span> <span class="num">0</span> <span class="round">)</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="ident">unquote</span><span class="round">(</span> <span class="ident">s</span><span class="op">,</span> <span class="ident">strStart</span><span class="square">[</span><span class="num">0</span><span class="square">]</span><span class="op">,</span> <span class="ident">strEnd</span><span class="square">[</span><span class="num">0</span><span class="square">]</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>


<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">// Same behavior as in unquote</span>
<span class="cmnt">//! \copydoc unquote</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">unquote_if_quoted</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotStart</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotEnd</span> <span class="op">=</span> <span class="num">0</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">unquote</span><span class="round">(</span> <span class="ident">s</span><span class="op">,</span> <span class="ident">quotStart</span><span class="op">,</span> <span class="ident">quotEnd</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! \copydoc unquote</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="kwd1">bool</span> <span class="ident">unquote_if_quoted</span><span class="round">(</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">s</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">quotStart</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">quotEnd</span> <span class="op">=</span> <span class="ident">StringType</span><span class="round">(</span><span class="round">)</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">return</span> <span class="ident">unquote</span><span class="round">(</span> <span class="ident">s</span><span class="op">,</span> <span class="ident">quotStart</span><span class="op">,</span> <span class="ident">quotEnd</span> <span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Закавычивает строку</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">quote</span><span class="round">(</span> <span class="kwd1">const</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="op">*</span><span class="ident">str</span>                                         <span class="cmnt">//!&lt; Строка для закавычивания</span>
                <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotStart</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="str">&apos;\&apos;&apos;</span>  <span class="cmnt">//!&lt; Открывающая кавычка</span>
                <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotEnd</span> <span class="op">=</span> <span class="num">0</span>                                        <span class="cmnt">//!&lt; Закрывающая кавычка, если 0 - то срабатывает автоопределение обоих кавычек (используются парные символы по открывающией кавычке)</span>
                <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">quotEnd</span><span class="op">==</span><span class="num">0</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="ident">quotEnd</span>   <span class="op">=</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_right</span><span class="round">(</span><span class="ident">quotStart</span><span class="round">)</span><span class="op">;</span>
        <span class="ident">quotStart</span> <span class="op">=</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_left</span><span class="round">(</span><span class="ident">quotStart</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="ident">StringType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">StringType</span><span class="round">(</span> <span class="num">1</span><span class="op">,</span> <span class="ident">quotStart</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">str</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span> <span class="num">1</span><span class="op">,</span> <span class="ident">quotEnd</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! \copydoc quote</span>
<span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">quote</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="op">&amp;</span><span class="ident">str</span>
                <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotStart</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span><span class="round">)</span><span class="str">&apos;\&apos;&apos;</span>
                <span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">::</span><span class="ident">value_type</span> <span class="ident">quotEnd</span> <span class="op">=</span> <span class="num">0</span>
                <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">quotStart</span> <span class="op">=</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_left</span><span class="round">(</span><span class="ident">quotStart</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">quotEnd</span>   <span class="op">=</span> <span class="ident">quotEnd</span><span class="op">==</span><span class="num">0</span> <span class="op">?</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_right</span><span class="round">(</span><span class="ident">quotStart</span><span class="round">)</span> <span class="op">:</span> <span class="ident">ascii_brace</span><span class="op">::</span><span class="ident">get_right</span><span class="round">(</span><span class="ident">quotEnd</span><span class="round">)</span><span class="op">;</span>

    <span class="ident">StringType</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">StringType</span><span class="round">(</span> <span class="num">1</span><span class="op">,</span> <span class="ident">quotStart</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span><span class="ident">str</span><span class="round">)</span><span class="op">;</span>
    <span class="ident">res</span><span class="op">.</span><span class="ident">append</span><span class="round">(</span> <span class="num">1</span><span class="op">,</span> <span class="ident">quotEnd</span> <span class="round">)</span><span class="op">;</span>
    <span class="kwd1">return</span> <span class="ident">res</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>





<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Хелпер для вычисления размера буфера для функции format_print</span>
<span class="kwd1">inline</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">calc_buf_char_size_for_format_print</span><span class="round">(</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">fmtStringSize</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">UMBA_ASSERT</span><span class="round">(</span><span class="ident">fmtStringSize</span><span class="op">&lt;</span><span class="num">256</span><span class="round">)</span><span class="op">;</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">bufSize</span> <span class="op">=</span> <span class="ident">fmtStringSize</span><span class="op">*</span><span class="num">16</span><span class="op">;</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">bufSize</span><span class="op">&lt;</span><span class="num">128</span><span class="round">)</span>
        <span class="ident">bufSize</span> <span class="op">=</span> <span class="num">128</span><span class="op">;</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">bufSize</span><span class="op">&gt;</span><span class="num">4096</span><span class="round">)</span>
        <span class="ident">bufSize</span> <span class="op">=</span> <span class="num">4096</span><span class="op">;</span>

    <span class="kwd1">return</span> <span class="ident">bufSize</span><span class="op">;</span>

<span class="curly">}</span>
<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Хелпер-обертка для sprintf и аналогичных платформо-зависимых аналогов.</span>
<span class="cmnt">/*!
    Используется vsnprintf.
    Теоретически, vsnprintf есть везде, но имя обычно чуть-чуть, но не такое как у других.
    Второе - не надо следить за буфером, его выделением, переполнением, и тп.
    Выбирается некоторый разумный размер буфера, лишнее - обрезается.
    Не следует задавать форматные строки огромной длины.
    Функция предназначена в основном для внутреннего использования, для printf-like быстрого форматирования интегральных величин,
    но теоретически можно использовать и форматные строки, задаваемые извне.

    Базовый шаблон вызовет ассерт, нужна специализация для конкретного типа

    \param fmt Форматная строка
 */</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">StringType</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">StringType</span> <span class="ident">format_print</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">StringType</span> <span class="ident">fmt</span><span class="op">,</span> <span class="op">...</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="ident">UMBA_ASSERT_FAIL</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! \copydoc format_print</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">format_print</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="op">&gt;</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span> <span class="ident">fmt</span><span class="op">,</span> <span class="op">...</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">fmt</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">return</span> <span class="ident">fmt</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">bufSize</span> <span class="op">=</span> <span class="ident">calc_buf_char_size_for_format_print</span> <span class="round">(</span><span class="ident">fmt</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">char</span> <span class="op">*</span><span class="ident">pBuf</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
    <span class="kwd1">try</span>
    <span class="curly">{</span>
        <span class="ident">pBuf</span> <span class="op">=</span> <span class="round">(</span><span class="kwd1">char</span><span class="op">*</span><span class="round">)</span><span class="ident">alloca</span><span class="round">(</span><span class="ident">bufSize</span><span class="op">*</span><span class="kwd1">sizeof</span><span class="round">(</span><span class="op">*</span><span class="ident">pBuf</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">pBuf</span><span class="round">)</span> <span class="kwd1">return</span> <span class="ident">fmt</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">catch</span><span class="round">(</span><span class="op">...</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">return</span> <span class="ident">fmt</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="pp">#<span class="ident">include</span> <span class="str">&quot;warnings/push_disable_non_portable_variadic.h&quot;</span>
</span>    <span class="ident">va_list</span> <span class="ident">args</span><span class="op">;</span>
    <span class="ident">va_start</span> <span class="round">(</span><span class="ident">args</span><span class="op">,</span> <span class="ident">fmt</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">auto</span> <span class="ident">numCharsPrinted</span> <span class="op">=</span> <span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="round">)</span><span class="ident">vsnprintf</span><span class="round">(</span><span class="ident">pBuf</span><span class="op">,</span><span class="ident">bufSize</span><span class="op">-</span><span class="num">1</span><span class="op">,</span> <span class="ident">fmt</span><span class="op">.</span><span class="ident">c_str</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">args</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">va_end</span> <span class="round">(</span><span class="ident">args</span><span class="round">)</span><span class="op">;</span>
    <span class="pp">#<span class="ident">include</span> <span class="str">&quot;warnings/pop.h&quot;</span>
</span>
    <span class="kwd1">return</span> <span class="ident">std</span><span class="op">::</span><span class="ident">string</span><span class="round">(</span><span class="ident">pBuf</span><span class="op">,</span> <span class="ident">numCharsPrinted</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>

<span class="pp">#<span class="ident">ifdef</span> <span class="ident">UMBA_MSVC_COMPILER_USED</span>
</span><span class="cmnt">//! \copydoc format_print</span>
<span class="kwd1">template</span> <span class="op">&lt;</span><span class="op">&gt;</span> <span class="kwd1">inline</span>
<span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="ident">format_print</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span><span class="op">&gt;</span><span class="round">(</span> <span class="kwd1">const</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span> <span class="ident">fmt</span><span class="op">,</span> <span class="op">...</span> <span class="round">)</span>
<span class="curly">{</span>
    <span class="kwd1">if</span> <span class="round">(</span><span class="ident">fmt</span><span class="op">.</span><span class="ident">empty</span><span class="round">(</span><span class="round">)</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">return</span> <span class="ident">fmt</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">bufSize</span> <span class="op">=</span> <span class="ident">calc_buf_char_size_for_format_print</span> <span class="round">(</span><span class="ident">fmt</span><span class="op">.</span><span class="ident">size</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">wchar_t</span> <span class="op">*</span><span class="ident">pBuf</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
    <span class="kwd1">try</span>
    <span class="curly">{</span>
        <span class="round">(</span><span class="kwd1">wchar_t</span><span class="op">*</span><span class="round">)</span><span class="ident">alloca</span><span class="round">(</span><span class="ident">bufSize</span><span class="op">*</span><span class="kwd1">sizeof</span><span class="round">(</span><span class="op">*</span><span class="ident">pBuf</span><span class="round">)</span><span class="round">)</span><span class="op">;</span>
        <span class="kwd1">if</span> <span class="round">(</span><span class="op">!</span><span class="ident">pBuf</span><span class="round">)</span> <span class="kwd1">return</span> <span class="ident">fmt</span><span class="op">;</span>
    <span class="curly">}</span>
    <span class="kwd1">catch</span><span class="round">(</span><span class="op">...</span><span class="round">)</span>
    <span class="curly">{</span>
        <span class="kwd1">return</span> <span class="ident">fmt</span><span class="op">;</span>
    <span class="curly">}</span>

    <span class="pp">#<span class="ident">include</span> <span class="str">&quot;warnings/push_disable_non_portable_variadic.h&quot;</span>
</span>    <span class="pp">#<span class="ident">include</span> <span class="str">&quot;warnings/disable_fn_or_var_unsafe.h&quot;</span>
</span>    <span class="ident">va_list</span> <span class="ident">args</span><span class="op">;</span>
    <span class="ident">va_start</span> <span class="round">(</span><span class="ident">args</span><span class="op">,</span> <span class="ident">fmt</span><span class="round">)</span><span class="op">;</span>
    <span class="kwd1">auto</span> <span class="ident">numCharsPrinted</span> <span class="op">=</span> <span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="round">)</span><span class="ident">_vsnwprintf</span><span class="round">(</span><span class="ident">pBuf</span><span class="op">,</span> <span class="ident">bufSize</span><span class="op">-</span><span class="num">1</span><span class="op">,</span> <span class="ident">fmt</span><span class="op">.</span><span class="ident">c_str</span><span class="round">(</span><span class="round">)</span><span class="op">,</span> <span class="ident">args</span> <span class="round">)</span><span class="op">;</span>
    <span class="ident">va_end</span> <span class="round">(</span><span class="ident">args</span><span class="round">)</span><span class="op">;</span>
    <span class="pp">#<span class="ident">include</span> <span class="str">&quot;warnings/pop.h&quot;</span>
</span>
    <span class="kwd1">return</span> <span class="ident">std</span><span class="op">::</span><span class="ident">wstring</span><span class="round">(</span><span class="ident">pBuf</span><span class="op">,</span> <span class="ident">numCharsPrinted</span><span class="round">)</span><span class="op">;</span>
<span class="curly">}</span>
<span class="pp">#<span class="ident">endif</span> <span class="cmnt">// UMBA_MSVC_COMPILER_USED</span>
</span>
<span class="cmnt">//-----------------------------------------------------------------------------</span>

<span class="cmnt">// End of UMBA_STRING_PLUS</span>
<span class="cmnt">/*! @}*/</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>



<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="curly">}</span> <span class="cmnt">// namespace string_plus</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>
<span class="cmnt">//! Алиас для совместимости совместимости со старым кодом</span>
<span class="cmnt">// namespace cpp = string_plus;</span>

<span class="cmnt">//-----------------------------------------------------------------------------</span>




<span class="cmnt">//-----------------------------------------------------------------------------</span>

<span class="curly">}</span> <span class="cmnt">// namespace umba</span>




</pre>
</body>
</html>
