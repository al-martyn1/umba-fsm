<html>
<head>
<meta charset="utf-8"/>
<style>


body {
  color:#1F377F;
}

.unxp{
}

.ident{
}

/********************/
.curly{
  color:black;
}

.round{
  color:black;
}

.angle{
  color:black;
}

.square{
  color:black;
}

.op{
  color:black;
  /* font-weight: bold; */
}

/********************/
.pp{
  color:green;
}

/********************/
.pp .curly{
  /*color:#004400;*/
  /*color:#003F00;*/
  color:#004200;
}

.pp .round{
  color:#004200;
}

.pp .angle{
  color:#004200;
}

.pp .square{
  color:#004200;
}

.pp .op{
  color:#004200;
}

.pp .num{
  color:#004200;
}

.pp .cmnt{
  color:#79AF79;
}

/********************/
.cmnt{
  //color:olive;
  color:#808080;
  font-style: italic;
}

.num{
  /* color:DarkRed; */
  /*color:#7A0000;*/
  color:#6A0000;
}

.str{
  /* color:Red; */
  color:#E21F1F;
}

.kwd1{
  color:blue;
}

.kwd2{
  color:green;
}


</style>
</head>
<body>
<pre>
<span class="cmnt">/*!
    \file
    \brief Перетащенное под старый Кейл type_traits из GCC
 */</span>

<span class="pp">#<span class="ident">pragma</span> <span class="ident">once</span>
</span>
<span class="pp">#<span class="ident">if</span> <span class="kwd2">defined</span><span class="round">(</span><span class="ident">UMBA_CXX_HAS_STD11</span><span class="round">)</span>
</span>    <span class="pp">#<span class="ident">include</span> <span class="op">&lt;</span><span class="ident">cstdint</span><span class="op">&gt;</span>
</span>
<span class="kwd1">namespace</span> <span class="ident">std</span>
<span class="curly">{</span>



  <span class="cmnt">/// integral_constant</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Tp</span> <span class="ident">__v</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">integral_constant</span>
    <span class="curly">{</span>
      <span class="kwd1">static</span> <span class="kwd1">constexpr</span> <span class="ident">_Tp</span>                  <span class="ident">value</span> <span class="op">=</span> <span class="ident">__v</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">_Tp</span>                           <span class="ident">value_type</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">__v</span><span class="op">&gt;</span>   <span class="ident">type</span><span class="op">;</span>
      <span class="kwd1">constexpr</span> <span class="kwd1">operator</span> <span class="ident">value_type</span><span class="round">(</span><span class="round">)</span> <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">value</span><span class="op">;</span> <span class="curly">}</span>
<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>
<span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_integral_constant_callable</span> <span class="num">201304</span>
</span>
      <span class="kwd1">constexpr</span> <span class="ident">value_type</span> <span class="kwd1">operator</span><span class="round">(</span><span class="round">)</span><span class="round">(</span><span class="round">)</span> <span class="kwd1">const</span> <span class="curly">{</span> <span class="kwd1">return</span> <span class="ident">value</span><span class="op">;</span> <span class="curly">}</span>
<span class="pp">#<span class="ident">endif</span>
</span>    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Tp</span> <span class="ident">__v</span><span class="op">&gt;</span>
    <span class="kwd1">constexpr</span> <span class="ident">_Tp</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">__v</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">;</span>

  <span class="cmnt">/// The type used as a compile-time boolean with true value.</span>
  <span class="kwd1">typedef</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>     <span class="ident">true_type</span><span class="op">;</span>

  <span class="cmnt">/// The type used as a compile-time boolean with false value.</span>
  <span class="kwd1">typedef</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>    <span class="ident">false_type</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span> <span class="ident">__v</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">__bool_constant</span> <span class="op">=</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__v</span><span class="op">&gt;</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201402L</span>
</span><span class="pp"># <span class="ident">define</span> <span class="ident">__cpp_lib_bool_constant</span> <span class="num">201505</span>
</span>  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span> <span class="ident">__v</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">bool_constant</span> <span class="op">=</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__v</span><span class="op">&gt;</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">// Meta programming helper types.</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">conditional</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__or_</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_B1</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">_B1</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_B1</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_B2</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">,</span> <span class="ident">_B2</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span> <span class="ident">_B1</span><span class="op">,</span> <span class="ident">_B2</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_B1</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_B2</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_B3</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Bn</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">,</span> <span class="ident">_B2</span><span class="op">,</span> <span class="ident">_B3</span><span class="op">,</span> <span class="ident">_Bn</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span> <span class="ident">_B1</span><span class="op">,</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">_B2</span><span class="op">,</span> <span class="ident">_B3</span><span class="op">,</span> <span class="ident">_Bn</span><span class="op">...</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__and_</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_B1</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">_B1</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_B1</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_B2</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">,</span> <span class="ident">_B2</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span> <span class="ident">_B2</span><span class="op">,</span> <span class="ident">_B1</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_B1</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_B2</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_B3</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Bn</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">,</span> <span class="ident">_B2</span><span class="op">,</span> <span class="ident">_B3</span><span class="op">,</span> <span class="ident">_Bn</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">_B1</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">_B2</span><span class="op">,</span> <span class="ident">_B3</span><span class="op">,</span> <span class="ident">_Bn</span><span class="op">...</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">_B1</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Pp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__not_</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="op">!</span><span class="ident">_Pp</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">struct</span> <span class="ident">__nonesuch</span> <span class="curly">{</span>
    <span class="ident">__nonesuch</span><span class="round">(</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">delete</span><span class="op">;</span>
    <span class="op">~</span><span class="ident">__nonesuch</span><span class="round">(</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">delete</span><span class="op">;</span>
    <span class="ident">__nonesuch</span><span class="round">(</span><span class="ident">__nonesuch</span> <span class="kwd1">const</span><span class="op">&amp;</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">delete</span><span class="op">;</span>
    <span class="kwd1">void</span> <span class="kwd1">operator</span><span class="op">=</span><span class="round">(</span><span class="ident">__nonesuch</span> <span class="kwd1">const</span><span class="op">&amp;</span><span class="round">)</span> <span class="op">=</span> <span class="kwd1">delete</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201402L</span>
</span>
<span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_logical_traits</span> <span class="num">201510</span>
</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Bn</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">conjunction</span>
    <span class="op">:</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">_Bn</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Bn</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">disjunction</span>
    <span class="op">:</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">_Bn</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Pp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">negation</span>
    <span class="op">:</span> <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">_Pp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">// For several sfinae-friendly trait implementations we transport both the</span>
  <span class="cmnt">// result information (as the member type) and the failure information (no</span>
  <span class="cmnt">// member type). This is very similar to std::enable_if, but we cannot use</span>
  <span class="cmnt">// them, because we need to derive from them as an implementation detail.</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__success_type</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">struct</span> <span class="ident">__failure_type</span>
  <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Primary type categories.</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_cv</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_void_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_void_helper</span><span class="op">&lt;</span><span class="kwd1">void</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_void</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_void</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_void_helper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">signed</span> <span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">char16_t</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">char32_t</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">short</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">short</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">int</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">int</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">long</span> <span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">long</span> <span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_integral</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_integral</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_integral_helper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_floating_point_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_floating_point_helper</span><span class="op">&lt;</span><span class="kwd1">float</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_floating_point_helper</span><span class="op">&lt;</span><span class="kwd1">double</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_floating_point_helper</span><span class="op">&lt;</span><span class="kwd1">long</span> <span class="kwd1">double</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

<span class="cmnt">//#if !defined(__STRICT_ANSI__) &amp;&amp; defined(_GLIBCXX_USE_FLOAT128)</span>
<span class="cmnt">//  template&lt;&gt;</span>
<span class="cmnt">//    struct __is_floating_point_helper&lt;__float128&gt;</span>
<span class="cmnt">//    : public true_type { };</span>
<span class="cmnt">//#endif</span>

  <span class="cmnt">/// is_floating_point</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_floating_point</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_floating_point_helper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_array</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_array</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">_Size</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="ident">_Size</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_pointer_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">*</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_pointer_helper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_lvalue_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_lvalue_reference</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_lvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_rvalue_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_rvalue_reference</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_member_object_pointer_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Cp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_member_object_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="ident">_Cp</span><span class="op">::</span><span class="op">*</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="op">!</span><span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_member_object_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_member_object_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_member_object_pointer_helper</span><span class="op">&lt;</span>
                <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_member_function_pointer_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Cp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_member_function_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="ident">_Cp</span><span class="op">::</span><span class="op">*</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_member_function_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_member_function_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_member_function_pointer_helper</span><span class="op">&lt;</span>
                <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_enum</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_enum</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_enum</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_union</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_union</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_union</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_class</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_class</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_class</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_function</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">volatile</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">volatile</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">volatile</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">volatile</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">volatile</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">volatile</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span> <span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">...</span><span class="round">)</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span> <span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_is_null_pointer</span> <span class="num">201309</span>
</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_null_pointer_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_null_pointer_helper</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">nullptr_t</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_null_pointer (LWG 2247).</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_null_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_null_pointer_helper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// __is_nullptr_t (extension).</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nullptr_t</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_null_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Composite type categories.</span>

  <span class="cmnt">/// is_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_reference</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_lvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                   <span class="ident">is_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_arithmetic</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_arithmetic</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_integral</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_floating_point</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_fundamental</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_fundamental</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_arithmetic</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
           <span class="ident">is_null_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_object</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_object</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                          <span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_member_pointer</span><span class="op">;</span>

  <span class="cmnt">/// is_scalar</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_scalar</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_arithmetic</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_enum</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                   <span class="ident">is_member_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_null_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_compound</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_compound</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="op">!</span><span class="ident">is_fundamental</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_member_pointer_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Cp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_member_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="ident">_Cp</span><span class="op">::</span><span class="op">*</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_member_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_member_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_member_pointer_helper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Utility to detect referenceable types ([defns.referenceable]).</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_referenceable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_object</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_Args</span><span class="op">...</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Res</span><span class="round">(</span><span class="ident">_Args</span><span class="op">...</span><span class="op">...</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Type properties.</span>

  <span class="cmnt">/// is_const</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_const</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_const</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="kwd1">const</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_volatile</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_volatile</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_volatile</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="kwd1">volatile</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivial</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivial</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_trivial</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// is_trivially_copyable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_copyable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_trivially_copyable</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_standard_layout</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_standard_layout</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_standard_layout</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_pod</span>
  <span class="cmnt">// Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_pod</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_pod</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_literal_type</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_literal_type</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_literal_type</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_empty</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_empty</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_empty</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_polymorphic</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_polymorphic</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_polymorphic</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;=</span> <span class="num">201402L</span>
</span><span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_is_final</span> <span class="num">201402L</span>
</span>  <span class="cmnt">/// is_final</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_final</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_final</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">/// is_abstract</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_abstract</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_abstract</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">is_arithmetic</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_signed_helper</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_signed_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">_Tp</span><span class="round">(</span><span class="op">-</span><span class="num">1</span><span class="round">)</span> <span class="op">&lt;</span> <span class="ident">_Tp</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_signed</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_signed</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_signed_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_unsigned</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_unsigned</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_arithmetic</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">is_signed</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Destructible and constructible type properties.</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_rvalue_reference</span><span class="op">;</span>

  <span class="cmnt">/**
   *  @brief  Utility to simplify expressions used in unevaluated operands
   *  @ingroup utilities
   */</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">typename</span> <span class="ident">add_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">declval</span><span class="round">(</span><span class="round">)</span> <span class="kwd1">noexcept</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="op">=</span> <span class="num">0</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">extent</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_all_extents</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_array_known_bounds</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="round">(</span><span class="ident">extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span> <span class="op">&gt;</span> <span class="num">0</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_array_unknown_bounds</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// In N3290 is_destructible does not say anything about function</span>
  <span class="cmnt">// types and abstract types, see LWG 2049. This implementation</span>
  <span class="cmnt">// describes function types as non-destructible and all complete</span>
  <span class="cmnt">// object types as destructible, iff the explicit destructor</span>
  <span class="cmnt">// call expression is wellformed.</span>
  <span class="kwd1">struct</span> <span class="ident">__do_is_destructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">.</span><span class="op">~</span><span class="ident">_Tp</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">true_type</span> <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_destructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_destructible_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span>
           <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                        <span class="ident">__is_array_unknown_bounds</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                        <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
           <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_scalar</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_destructible_safe</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_destructible_impl</span><span class="op">&lt;</span><span class="kwd1">typename</span>
               <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_destructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_destructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// is_nothrow_destructible requires that is_destructible is</span>
  <span class="cmnt">// satisfied as well.  We realize that by mimicing the</span>
  <span class="cmnt">// implementation of is_destructible but refer to noexcept(expr)</span>
  <span class="cmnt">// instead of decltype(expr).</span>
  <span class="kwd1">struct</span> <span class="ident">__do_is_nt_destructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">noexcept</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">.</span><span class="op">~</span><span class="ident">_Tp</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
        <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_destructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_nt_destructible_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span>
           <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                        <span class="ident">__is_array_unknown_bounds</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                        <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
           <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_scalar</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_destructible_safe</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nt_destructible_impl</span><span class="op">&lt;</span><span class="kwd1">typename</span>
               <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_destructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_destructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nt_destructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">struct</span> <span class="ident">__do_is_default_constructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">true_type</span> <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_default_constructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_default_constructible_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_default_constructible_atom</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">,</span>
                    <span class="ident">__is_default_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_default_constructible_safe</span><span class="op">;</span>

  <span class="cmnt">// The following technique is a workaround for a current core language</span>
  <span class="cmnt">// restriction, which does not allow for array types to occur in</span>
  <span class="cmnt">// functional casts of the form T().  Complete arrays can be default-</span>
  <span class="cmnt">// constructed, if the element type is default-constructible, but</span>
  <span class="cmnt">// arrays with unknown bounds are not.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_default_constructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">__is_array_known_bounds</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">__is_default_constructible_atom</span><span class="op">&lt;</span><span class="kwd1">typename</span>
                      <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_default_constructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_default_constructible_atom</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_default_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_default_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_default_constructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Implementation of is_constructible.</span>

  <span class="cmnt">// The hardest part of this trait is the binary direct-initialization</span>
  <span class="cmnt">// case, because we hit into a functional cast of the form T(arg).</span>
  <span class="cmnt">// This implementation uses different strategies depending on the</span>
  <span class="cmnt">// target type to reduce the test overhead as much as possible:</span>
  <span class="cmnt">//
  // a) For a reference target type, we use a static_cast expression</span>
  <span class="cmnt">//    modulo its extra cases.</span>
  <span class="cmnt">//
  // b) For a non-reference target type we use a ::new expression.</span>
  <span class="kwd1">struct</span> <span class="ident">__do_is_static_castable_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">typename</span>
             <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="kwd1">static_cast</span><span class="op">&lt;</span><span class="ident">_To</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">true_type</span> <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_static_castable_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_static_castable_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_static_castable_safe</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_static_castable_impl</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// __is_static_castable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_static_castable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="round">(</span><span class="ident">__is_static_castable_safe</span><span class="op">&lt;</span>
                      <span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Implementation for non-reference types. To meet the proper</span>
  <span class="cmnt">// variable definition semantics, we also need to test for</span>
  <span class="cmnt">// is_destructible in this case.</span>
  <span class="cmnt">// This form should be simplified by a single expression:</span>
  <span class="cmnt">// ::delete ::new _Tp(declval&lt;_Arg&gt;()), see c++/51222.</span>
  <span class="kwd1">struct</span> <span class="ident">__do_is_direct_constructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span>
         <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="op">::</span><span class="kwd1">new</span> <span class="ident">_Tp</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">true_type</span> <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_direct_constructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_direct_constructible_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_direct_constructible_new_safe</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_destructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                    <span class="ident">__is_direct_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_same</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_base_of</span><span class="op">;</span>

<span class="cmnt">/*
  template&lt;typename&gt;
    struct remove_reference;
*/</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">bool</span>
           <span class="op">=</span> <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">&gt;</span><span class="op">,</span>
                          <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_base_to_derived_ref</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_constructible</span><span class="op">;</span>

  <span class="cmnt">// Detect whether we have a downcast situation during</span>
  <span class="cmnt">// reference binding.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_base_to_derived_ref</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_From</span>
        <span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__src_t</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_To</span>
        <span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__dst_t</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">is_same</span><span class="op">&lt;</span><span class="ident">__src_t</span><span class="op">,</span> <span class="ident">__dst_t</span><span class="op">&gt;&gt;</span><span class="op">,</span>
             <span class="ident">is_base_of</span><span class="op">&lt;</span><span class="ident">__src_t</span><span class="op">,</span> <span class="ident">__dst_t</span><span class="op">&gt;</span><span class="op">,</span>
             <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">is_constructible</span><span class="op">&lt;</span><span class="ident">__dst_t</span><span class="op">,</span> <span class="ident">_From</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span> <span class="ident">type</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">constexpr</span> <span class="kwd1">bool</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">type</span><span class="op">::</span><span class="ident">value</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_base_to_derived_ref</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">bool</span>
           <span class="op">=</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_lvalue_reference</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">&gt;</span><span class="op">,</span>
                    <span class="ident">is_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_To</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_lvalue_to_rvalue_ref</span><span class="op">;</span>

  <span class="cmnt">// Detect whether we have an lvalue of non-function type</span>
  <span class="cmnt">// bound to a reference-compatible rvalue-reference.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_lvalue_to_rvalue_ref</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span>
        <span class="ident">_From</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__src_t</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span>
        <span class="ident">_To</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__dst_t</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">__src_t</span><span class="op">&gt;&gt;</span><span class="op">,</span>
        <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_same</span><span class="op">&lt;</span><span class="ident">__src_t</span><span class="op">,</span> <span class="ident">__dst_t</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">is_base_of</span><span class="op">&lt;</span><span class="ident">__dst_t</span><span class="op">,</span> <span class="ident">__src_t</span><span class="op">&gt;&gt;</span><span class="op">&gt;</span> <span class="ident">type</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">constexpr</span> <span class="kwd1">bool</span> <span class="ident">value</span> <span class="op">=</span> <span class="ident">type</span><span class="op">::</span><span class="ident">value</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_lvalue_to_rvalue_ref</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Here we handle direct-initialization to a reference type as</span>
  <span class="cmnt">// equivalent to a static_cast modulo overshooting conversions.</span>
  <span class="cmnt">// These are restricted to the following conversions:</span>
  <span class="cmnt">//    a) A base class value to a derived class reference</span>
  <span class="cmnt">//    b) An lvalue to an rvalue-reference of reference-compatible</span>
  <span class="cmnt">//       types that are not functions</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_direct_constructible_ref_cast</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">__is_static_castable</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                    <span class="ident">__not_</span><span class="op">&lt;</span><span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">__is_base_to_derived_ref</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                                 <span class="ident">__is_lvalue_to_rvalue_ref</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
                   <span class="op">&gt;&gt;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_direct_constructible_new</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">is_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
             <span class="ident">__is_direct_constructible_ref_cast</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">,</span>
             <span class="ident">__is_direct_constructible_new_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
             <span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_direct_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_direct_constructible_new</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Since default-construction and binary direct-initialization have</span>
  <span class="cmnt">// been handled separately, the implementation of the remaining</span>
  <span class="cmnt">// n-ary construction cases is rather straightforward. We can use</span>
  <span class="cmnt">// here a functional cast, because array types are excluded anyway</span>
  <span class="cmnt">// and this form is never interpreted as a C cast.</span>
  <span class="kwd1">struct</span> <span class="ident">__do_is_nary_constructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">,</span> <span class="kwd1">typename</span>
             <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">...</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">true_type</span> <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nary_constructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_nary_constructible_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nary_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nary_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span>
      <span class="kwd1">static_assert</span><span class="round">(</span><span class="kwd1">sizeof</span><span class="op">...</span><span class="round">(</span><span class="ident">_Args</span><span class="round">)</span> <span class="op">&gt;</span> <span class="num">1</span><span class="op">,</span>
                    <span class="str">&quot;Only useful for &gt; 1 arguments&quot;</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_constructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nary_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_direct_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_default_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_copy_constructible_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_copy_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_copy_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_copy_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_copy_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_copy_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_move_constructible_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_move_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_move_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_move_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_move_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_move_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_default_constructible_atom</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">noexcept</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_default_constructible_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_default_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">__is_array_known_bounds</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">__is_nt_default_constructible_atom</span><span class="op">&lt;</span><span class="kwd1">typename</span>
                      <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_default_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nt_default_constructible_atom</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_default_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_default_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_default_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                    <span class="ident">__is_nt_default_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_constructible_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">noexcept</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">...</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
                               <span class="kwd1">noexcept</span><span class="round">(</span><span class="kwd1">static_cast</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_nothrow_default_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">__is_nt_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nothrow_copy_constructible_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nothrow_copy_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nothrow_copy_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_nothrow_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_copy_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_copy_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nothrow_copy_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nothrow_move_constructible_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nothrow_move_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nothrow_move_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_nothrow_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_move_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_move_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nothrow_move_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__is_assignable_helper</span>
    <span class="curly">{</span>
      <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp1</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up1</span><span class="op">,</span>
           <span class="kwd1">typename</span> <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="op">=</span> <span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Up1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="ident">true_type</span>
    <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

      <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="ident">false_type</span>
    <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_assignable</span>
      <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_assignable_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_copy_assignable_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_copy_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_copy_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_copy_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_copy_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_copy_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_move_assignable_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_move_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_move_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_move_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_move_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_move_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_assignable_impl</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">noexcept</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span> <span class="op">=</span> <span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">__is_nt_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_copy_assignable_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_copy_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_copy_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_nothrow_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_copy_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_copy_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nt_copy_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_move_assignable_impl</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_move_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_nt_move_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_nothrow_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_nothrow_move_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_nothrow_move_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_nt_move_assignable_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
            <span class="ident">__is_trivially_constructible</span><span class="round">(</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_default_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_default_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">is_trivially_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">struct</span> <span class="ident">__do_is_implicitly_default_constructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="kwd1">void</span> <span class="ident">__helper</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="ident">true_type</span> <span class="ident">__test</span><span class="round">(</span><span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span>
                            <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__helper</span><span class="op">&lt;</span><span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">&gt;</span><span class="round">(</span><span class="curly">{</span><span class="curly">}</span><span class="round">)</span><span class="round">)</span><span class="op">*</span> <span class="op">=</span> <span class="num">0</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">static</span> <span class="ident">false_type</span> <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_implicitly_default_constructible_impl</span>
      <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__do_is_implicitly_default_constructible_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="round">(</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_implicitly_default_constructible_safe</span>
      <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_implicitly_default_constructible_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
  <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span> <span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_implicitly_default_constructible</span>
      <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_default_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                      <span class="ident">__is_implicitly_default_constructible_safe</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span>
  <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_copy_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_copy_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_copy_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
            <span class="ident">__is_trivially_constructible</span><span class="round">(</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_move_constructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_move_constructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_move_constructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
            <span class="ident">__is_trivially_constructible</span><span class="round">(</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
            <span class="ident">__is_trivially_assignable</span><span class="round">(</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_copy_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_copy_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_copy_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
            <span class="ident">__is_trivially_assignable</span><span class="round">(</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">_Tp</span><span class="op">&amp;</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_move_assignable</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_move_assignable</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_move_assignable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
            <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
            <span class="ident">__is_trivially_assignable</span><span class="round">(</span><span class="ident">_Tp</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_trivially_destructible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_trivially_destructible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">is_destructible</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span>
                  <span class="ident">__has_trivial_destructor</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// has_trivial_default_constructor (temporary legacy)</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">has_trivial_default_constructor</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__has_trivial_constructor</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span>  <span class="cmnt">/* _GLIBCXX_DEPRECATED */</span> <span class="op">;</span>

  <span class="cmnt">/// has_trivial_copy_constructor (temporary legacy)</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">has_trivial_copy_constructor</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__has_trivial_copy</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span>  <span class="cmnt">/* _GLIBCXX_DEPRECATED */</span> <span class="op">;</span>

  <span class="cmnt">/// has_trivial_copy_assign (temporary legacy)</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">has_trivial_copy_assign</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__has_trivial_assign</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span>  <span class="cmnt">/* _GLIBCXX_DEPRECATED */</span> <span class="op">;</span>

  <span class="cmnt">/// has_virtual_destructor</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">has_virtual_destructor</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__has_virtual_destructor</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// type property queries.</span>

  <span class="cmnt">/// alignment_of</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">alignment_of</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span> <span class="ident">__alignof__</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// rank</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">rank</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span> <span class="num">0</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">_Size</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">rank</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="ident">_Size</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span> <span class="num">1</span> <span class="op">+</span> <span class="ident">rank</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">rank</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span> <span class="num">1</span> <span class="op">+</span> <span class="ident">rank</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// extent</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="ident">_Uint</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">extent</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span> <span class="num">0</span><span class="op">&gt;</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="ident">_Uint</span><span class="op">,</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">_Size</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="ident">_Size</span><span class="square">]</span><span class="op">,</span> <span class="ident">_Uint</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span>
                   <span class="ident">_Uint</span> <span class="op">==</span> <span class="num">0</span> <span class="op">?</span> <span class="ident">_Size</span> <span class="op">:</span> <span class="ident">extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span>
                               <span class="ident">_Uint</span> <span class="op">-</span> <span class="num">1</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="ident">_Uint</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="square">]</span><span class="op">,</span> <span class="ident">_Uint</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span><span class="op">,</span>
                   <span class="ident">_Uint</span> <span class="op">==</span> <span class="num">0</span> <span class="op">?</span> <span class="num">0</span> <span class="op">:</span> <span class="ident">extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span>
                                          <span class="ident">_Uint</span> <span class="op">-</span> <span class="num">1</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Type relations.</span>

  <span class="cmnt">/// is_same</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_same</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">false_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_same</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">true_type</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// is_base_of</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Base</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Derived</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_base_of</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">integral_constant</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="ident">__is_base_of</span><span class="round">(</span><span class="ident">_Base</span><span class="op">,</span> <span class="ident">_Derived</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">,</span>
           <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_To</span><span class="op">&gt;</span><span class="op">,</span>
                        <span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_To</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__is_convertible_helper</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_To</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__is_convertible_helper</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span>
       <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_To1</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="kwd1">void</span> <span class="ident">__test_aux</span><span class="round">(</span><span class="ident">_To1</span><span class="round">)</span><span class="op">;</span>

      <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From1</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To1</span><span class="op">,</span>
           <span class="kwd1">typename</span> <span class="op">=</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test_aux</span><span class="op">&lt;</span><span class="ident">_To1</span><span class="op">&gt;</span><span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_From1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="ident">true_type</span>
    <span class="ident">__test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

      <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">static</span> <span class="ident">false_type</span>
    <span class="ident">__test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">__test</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">/// is_convertible</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_From</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_To</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">is_convertible</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__is_convertible_helper</span><span class="op">&lt;</span><span class="ident">_From</span><span class="op">,</span> <span class="ident">_To</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Const-volatile modifications.</span>

  <span class="cmnt">/// remove_const</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_const</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_const</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="kwd1">const</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// remove_volatile</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_volatile</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_volatile</span><span class="op">&lt;</span><span class="ident">_Tp</span> <span class="kwd1">volatile</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// remove_cv</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_cv</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span>
      <span class="ident">remove_const</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_volatile</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>     <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// add_const</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_const</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="kwd1">const</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// add_volatile</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_volatile</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="kwd1">volatile</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// add_cv</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_cv</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span>
      <span class="ident">add_const</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">add_volatile</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>     <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>
<span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_transformation_trait_aliases</span> <span class="num">201304</span>
</span>
  <span class="cmnt">/// Alias template for remove_const</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_const_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_const</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for remove_volatile</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_volatile_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_volatile</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for remove_cv</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_cv_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for add_const</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">add_const_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">add_const</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for add_volatile</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">add_volatile_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">add_volatile</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for add_cv</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">add_cv_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">add_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">// Reference transformations.</span>

<span class="cmnt">/*
  /// remove_reference
  template&lt;typename _Tp&gt;
    struct remove_reference
    { typedef _Tp   type; };

  template&lt;typename _Tp&gt;
    struct remove_reference&lt;_Tp&amp;&gt;
    { typedef _Tp   type; };

  template&lt;typename _Tp&gt;
    struct remove_reference&lt;_Tp&amp;&amp;&gt;
    { typedef _Tp   type; };
*/</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__add_lvalue_reference_helper</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>   <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__add_lvalue_reference_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span><span class="op">&amp;</span>   <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// add_lvalue_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_lvalue_reference</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__add_lvalue_reference_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__add_rvalue_reference_helper</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>   <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__add_rvalue_reference_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span><span class="op">&amp;&amp;</span>   <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// add_rvalue_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_rvalue_reference</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__add_rvalue_reference_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>  <span class="cmnt">/// Alias template for remove_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_reference_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for add_lvalue_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">add_lvalue_reference_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">add_lvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for add_rvalue_reference</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">add_rvalue_reference_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">add_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">// Sign modifications.</span>

  <span class="cmnt">// Utility for constructing identically cv-qualified types.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Unqualified</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">_IsConst</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="ident">_IsVol</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__cv_selector</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Unqualified</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__cv_selector</span><span class="op">&lt;</span><span class="ident">_Unqualified</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Unqualified</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Unqualified</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__cv_selector</span><span class="op">&lt;</span><span class="ident">_Unqualified</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">volatile</span> <span class="ident">_Unqualified</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Unqualified</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__cv_selector</span><span class="op">&lt;</span><span class="ident">_Unqualified</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">const</span> <span class="ident">_Unqualified</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Unqualified</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__cv_selector</span><span class="op">&lt;</span><span class="ident">_Unqualified</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">const</span> <span class="kwd1">volatile</span> <span class="ident">_Unqualified</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Qualified</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Unqualified</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsConst</span> <span class="op">=</span> <span class="ident">is_const</span><span class="op">&lt;</span><span class="ident">_Qualified</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsVol</span> <span class="op">=</span> <span class="ident">is_volatile</span><span class="op">&lt;</span><span class="ident">_Qualified</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__match_cv_qualifiers</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">__cv_selector</span><span class="op">&lt;</span><span class="ident">_Unqualified</span><span class="op">,</span> <span class="ident">_IsConst</span><span class="op">,</span> <span class="ident">_IsVol</span><span class="op">&gt;</span> <span class="ident">__match</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__match</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Utility for finding the unsigned versions of signed integral types.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">char</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">signed</span> <span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">char</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">short</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">short</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">int</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">int</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">long</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">long</span> <span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">long</span> <span class="kwd1">long</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Select between integral and enum: not possible to be both.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsInt</span> <span class="op">=</span> <span class="ident">is_integral</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsEnum</span> <span class="op">=</span> <span class="ident">is_enum</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__make_unsigned_selector</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__make_unsigned_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">__make_unsigned</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span> <span class="ident">__unsignedt</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__unsignedt</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__unsigned_type</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">__match_cv_qualifiers</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">__unsigned_type</span><span class="op">&gt;</span> <span class="ident">__cv_unsigned</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__cv_unsigned</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__make_unsigned_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="cmnt">// With -fshort-enums, an enum may be as small as a char.</span>
      <span class="kwd1">typedef</span> <span class="kwd1">unsigned</span> <span class="kwd1">char</span> <span class="ident">__smallest</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">const</span> <span class="kwd1">bool</span> <span class="ident">__b0</span> <span class="op">=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span> <span class="op">&lt;=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="ident">__smallest</span><span class="round">)</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">const</span> <span class="kwd1">bool</span> <span class="ident">__b1</span> <span class="op">=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span> <span class="op">&lt;=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="kwd1">unsigned</span> <span class="kwd1">short</span><span class="round">)</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">const</span> <span class="kwd1">bool</span> <span class="ident">__b2</span> <span class="op">=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span> <span class="op">&lt;=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="kwd1">unsigned</span> <span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">const</span> <span class="kwd1">bool</span> <span class="ident">__b3</span> <span class="op">=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span> <span class="op">&lt;=</span> <span class="kwd1">sizeof</span><span class="round">(</span><span class="kwd1">unsigned</span> <span class="kwd1">long</span><span class="round">)</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">__b3</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="kwd1">long</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="kwd1">long</span> <span class="kwd1">long</span><span class="op">&gt;</span> <span class="ident">__cond3</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__cond3</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__cond3_type</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">__b2</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="kwd1">int</span><span class="op">,</span> <span class="ident">__cond3_type</span><span class="op">&gt;</span> <span class="ident">__cond2</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__cond2</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__cond2_type</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">__b1</span><span class="op">,</span> <span class="kwd1">unsigned</span> <span class="kwd1">short</span><span class="op">,</span> <span class="ident">__cond2_type</span><span class="op">&gt;</span> <span class="ident">__cond1</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__cond1</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__cond1_type</span><span class="op">;</span>

      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">__b0</span><span class="op">,</span> <span class="ident">__smallest</span><span class="op">,</span> <span class="ident">__cond1_type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="ident">__unsigned_type</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">__match_cv_qualifiers</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">__unsigned_type</span><span class="op">&gt;</span> <span class="ident">__cv_unsigned</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__cv_unsigned</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Given an integral/enum type, return the corresponding unsigned</span>
  <span class="cmnt">// integer type.</span>
  <span class="cmnt">// Primary template.</span>
  <span class="cmnt">/// make_unsigned</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">make_unsigned</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__make_unsigned_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Integral, but don&apos;t define.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">make_unsigned</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">&gt;</span><span class="op">;</span>


  <span class="cmnt">// Utility for finding the signed versions of unsigned integral types.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">signed</span> <span class="kwd1">char</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">char</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">signed</span> <span class="kwd1">char</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">short</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">signed</span> <span class="kwd1">short</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">int</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">signed</span> <span class="kwd1">int</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">signed</span> <span class="kwd1">long</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">unsigned</span> <span class="kwd1">long</span> <span class="kwd1">long</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">signed</span> <span class="kwd1">long</span> <span class="kwd1">long</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Select between integral and enum: not possible to be both.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsInt</span> <span class="op">=</span> <span class="ident">is_integral</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsEnum</span> <span class="op">=</span> <span class="ident">is_enum</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__make_signed_selector</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__make_signed_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">__make_signed</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span> <span class="ident">__signedt</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__signedt</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__signed_type</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">__match_cv_qualifiers</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">__signed_type</span><span class="op">&gt;</span> <span class="ident">__cv_signed</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__cv_signed</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">__make_signed_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__make_unsigned_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__unsigned_type</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__make_signed_selector</span><span class="op">&lt;</span><span class="ident">__unsigned_type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Given an integral/enum type, return the corresponding signed</span>
  <span class="cmnt">// integer type.</span>
  <span class="cmnt">// Primary template.</span>
  <span class="cmnt">/// make_signed</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">make_signed</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__make_signed_selector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Integral, but don&apos;t define.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">make_signed</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">&gt;</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>  <span class="cmnt">/// Alias template for make_signed</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">make_signed_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">make_signed</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for make_unsigned</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">make_unsigned_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">make_unsigned</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">// Array modifications.</span>

  <span class="cmnt">/// remove_extent</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_extent</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">_Size</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="ident">_Size</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// remove_all_extents</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_all_extents</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="ident">std</span><span class="op">::</span><span class="ident">size_t</span> <span class="ident">_Size</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="ident">_Size</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="square">[</span><span class="square">]</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>  <span class="cmnt">/// Alias template for remove_extent</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_extent_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_extent</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for remove_all_extents</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_all_extents_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_all_extents</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">// Pointer modifications.</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__remove_pointer_helper</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__remove_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">*</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Up</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// remove_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">remove_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__remove_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// add_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">bool</span> <span class="op">=</span> <span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">__is_referenceable</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">,</span>
                      <span class="ident">is_void</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__add_pointer_helper</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__add_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">*</span>     <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">add_pointer</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__add_pointer_helper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>  <span class="cmnt">/// Alias template for remove_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">remove_pointer_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">remove_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for add_pointer</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">add_pointer_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">add_pointer</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
<span class="cmnt">/*
  template&lt;std::size_t _Len&gt;
    struct __aligned_storage_msa
    {
      union __type
      {
          unsigned char __data[_Len];
          struct __attribute__((__aligned__)) { } __align;
      };
    };
*/</span>
  <span class="cmnt">/**
   *  @brief Alignment type.
   *
   *  The value of _Align is a default-alignment which shall be the
   *  most stringent alignment requirement for any C++ object type
   *  whose size is no greater than _Len (3.9). The member typedef
   *  type shall be a POD type suitable for use as uninitialized
   *  storage for any object whose size is at most _Len and whose
   *  alignment is a divisor of _Align.
  */</span>
<span class="cmnt">/*
  template&lt;std::size_t _Len, std::size_t _Align =
       __alignof__(typename __aligned_storage_msa&lt;_Len&gt;::__type)&gt;
    struct aligned_storage
    {
      union type
      {
          unsigned char __data[_Len];
          struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };
*/</span>

<span class="cmnt">/*
  template &lt;typename... _Types&gt;
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template &lt;typename _Tp, typename... _Types&gt;
    struct __strictest_alignment&lt;_Tp, _Types...&gt;
    {
      static const size_t _S_alignment =
        alignof(_Tp) &gt; __strictest_alignment&lt;_Types...&gt;::_S_alignment
    ? alignof(_Tp) : __strictest_alignment&lt;_Types...&gt;::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) &gt; __strictest_alignment&lt;_Types...&gt;::_S_size
    ? sizeof(_Tp) : __strictest_alignment&lt;_Types...&gt;::_S_size;
    };
*/</span>
  <span class="cmnt">/**
   *  @brief Provide aligned storage for types.
   *
   *  [meta.trans.other]
   *
   *  Provides aligned storage for any of the provided types of at
   *  least size _Len.
   *
   *  @see aligned_storage
   */</span>
<span class="cmnt">/*
  template &lt;size_t _Len, typename... _Types&gt;
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, &quot;At least one type is required&quot;);

      using __strictest = __strictest_alignment&lt;_Types...&gt;;
      static const size_t _S_len = _Len &gt; __strictest::_S_size
    ? _Len : __strictest::_S_size;
    public:
      /// The value of the strictest alignment of _Types.
      static const size_t alignment_value = __strictest::_S_alignment;
      /// The storage.
      typedef typename aligned_storage&lt;_S_len, alignment_value&gt;::type type;
    };

  template &lt;size_t _Len, typename... _Types&gt;
    const size_t aligned_union&lt;_Len, _Types...&gt;::alignment_value;
*/</span>
  <span class="cmnt">// Decay trait for arrays and functions, used for perfect forwarding</span>
  <span class="cmnt">// in make_pair, make_tuple, etc.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsArray</span> <span class="op">=</span> <span class="ident">is_array</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
       <span class="kwd1">bool</span> <span class="ident">_IsFunction</span> <span class="op">=</span> <span class="ident">is_function</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__decay_selector</span><span class="op">;</span>

  <span class="cmnt">// NB: DR 705.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__decay_selector</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__decay_selector</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_extent</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">*</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__decay_selector</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">add_pointer</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// decay</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">decay</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__remove_type</span><span class="op">;</span>

    <span class="kwd1">public</span><span class="op">:</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__decay_selector</span><span class="op">&lt;</span><span class="ident">__remove_type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">reference_wrapper</span><span class="op">;</span>

  <span class="cmnt">// Helper which adds a reference to a type when given a reference_wrapper</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__strip_reference_wrapper</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__strip_reference_wrapper</span><span class="op">&lt;</span><span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span> <span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">_Tp</span><span class="op">&amp;</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__decay_and_strip</span>
    <span class="curly">{</span>
        <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">__strip_reference_wrapper</span><span class="op">&lt;</span>
        <span class="kwd1">typename</span> <span class="ident">decay</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__type</span> <span class="ident">__type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>


  <span class="cmnt">// Primary template.</span>
  <span class="cmnt">/// Define a member typedef @c type only if a boolean constant is true.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tp</span> <span class="op">=</span> <span class="kwd1">void</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">enable_if</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Partial specialization for true.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">enable_if</span><span class="op">&lt;</span><span class="kwd1">true</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Tp</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Cond</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">_Require</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">enable_if</span><span class="op">&lt;</span><span class="ident">__and_</span><span class="op">&lt;</span><span class="ident">_Cond</span><span class="op">...</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">// Primary template.</span>
  <span class="cmnt">/// Define a member typedef @c type to one of two argument types.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span> <span class="ident">_Cond</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Iftrue</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Iffalse</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">conditional</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Iftrue</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Partial specialization for false.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Iftrue</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Iffalse</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="kwd1">false</span><span class="op">,</span> <span class="ident">_Iftrue</span><span class="op">,</span> <span class="ident">_Iffalse</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">_Iffalse</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// common_type</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">common_type</span><span class="op">;</span>

  <span class="cmnt">// Sfinae-friendly common_type implementation:</span>

  <span class="kwd1">struct</span> <span class="ident">__do_common_type_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__success_type</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">decay</span><span class="op">&lt;</span><span class="kwd1">decltype</span>
                <span class="round">(</span><span class="kwd1">true</span> <span class="op">?</span> <span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span>
                 <span class="op">:</span> <span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Up</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__common_type_impl</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__do_common_type_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">struct</span> <span class="ident">__do_member_type_wrapper</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__success_type</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__member_type_wrapper</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__do_member_type_wrapper</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_CTp</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__expanded_common_type_wrapper</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">common_type</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_CTp</span><span class="op">::</span><span class="ident">type</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__expanded_common_type_wrapper</span><span class="op">&lt;</span><span class="ident">__failure_type</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="ident">__failure_type</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">common_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">decay</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">type</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">common_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__common_type_impl</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Up</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Vp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">common_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">,</span> <span class="ident">_Vp</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__expanded_common_type_wrapper</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">__member_type_wrapper</span><span class="op">&lt;</span>
               <span class="ident">common_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">,</span> <span class="ident">_Up</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">,</span> <span class="ident">_Vp</span><span class="op">...</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// The underlying type of an enum.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">underlying_type</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">__underlying_type</span><span class="round">(</span><span class="ident">_Tp</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__declval_protector</span>
    <span class="curly">{</span>
      <span class="kwd1">static</span> <span class="kwd1">const</span> <span class="kwd1">bool</span> <span class="ident">__stop</span> <span class="op">=</span> <span class="kwd1">false</span><span class="op">;</span>
      <span class="kwd1">static</span> <span class="kwd1">typename</span> <span class="ident">add_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">__delegate</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">inline</span> <span class="kwd1">typename</span> <span class="ident">add_rvalue_reference</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="ident">declval</span><span class="round">(</span><span class="round">)</span> <span class="kwd1">noexcept</span>
    <span class="curly">{</span>
      <span class="kwd1">static_assert</span><span class="round">(</span><span class="ident">__declval_protector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__stop</span><span class="op">,</span>
            <span class="str">&quot;declval() must not be used!&quot;</span><span class="round">)</span><span class="op">;</span>
      <span class="kwd1">return</span> <span class="ident">__declval_protector</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">__delegate</span><span class="round">(</span><span class="round">)</span><span class="op">;</span>
    <span class="curly">}</span>

  <span class="cmnt">/// result_of</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Signature</span><span class="op">&gt;</span>
    <span class="kwd1">class</span> <span class="ident">result_of</span><span class="op">;</span>

  <span class="cmnt">// Sfinae-friendly result_of implementation:</span>

<span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_result_of_sfinae</span> <span class="num">201210</span>
</span>
  <span class="kwd1">struct</span> <span class="ident">__invoke_memfun_ref</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>
  <span class="kwd1">struct</span> <span class="ident">__invoke_memfun_deref</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>
  <span class="kwd1">struct</span> <span class="ident">__invoke_memobj_ref</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>
  <span class="kwd1">struct</span> <span class="ident">__invoke_memobj_deref</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>
  <span class="kwd1">struct</span> <span class="ident">__invoke_other</span> <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Associate a tag type with a specialization of __success_type.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tag</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_success</span> <span class="op">:</span> <span class="ident">__success_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="kwd1">using</span> <span class="ident">__invoke_type</span> <span class="op">=</span> <span class="ident">_Tag</span><span class="op">;</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// [func.require] paragraph 1 bullet 1:</span>
  <span class="kwd1">struct</span> <span class="ident">__result_of_memfun_ref_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Fp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tp1</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__result_of_success</span><span class="op">&lt;</span><span class="kwd1">decltype</span><span class="round">(</span>
      <span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">.*</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Fp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">...</span><span class="round">)</span>
      <span class="round">)</span><span class="op">,</span> <span class="ident">__invoke_memfun_ref</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun_ref</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__result_of_memfun_ref_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// [func.require] paragraph 1 bullet 2:</span>
  <span class="kwd1">struct</span> <span class="ident">__result_of_memfun_deref_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Fp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tp1</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__result_of_success</span><span class="op">&lt;</span><span class="kwd1">decltype</span><span class="round">(</span>
      <span class="round">(</span><span class="round">(</span><span class="op">*</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">.*</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Fp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">...</span><span class="round">)</span>
      <span class="round">)</span><span class="op">,</span> <span class="ident">__invoke_memfun_deref</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun_deref</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__result_of_memfun_deref_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// [func.require] paragraph 1 bullet 3:</span>
  <span class="kwd1">struct</span> <span class="ident">__result_of_memobj_ref_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Fp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tp1</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__result_of_success</span><span class="op">&lt;</span><span class="kwd1">decltype</span><span class="round">(</span>
      <span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">.*</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Fp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span>
      <span class="round">)</span><span class="op">,</span> <span class="ident">__invoke_memobj_ref</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj_ref</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__result_of_memobj_ref_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// [func.require] paragraph 1 bullet 4:</span>
  <span class="kwd1">struct</span> <span class="ident">__result_of_memobj_deref_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Fp</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tp1</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__result_of_success</span><span class="op">&lt;</span><span class="kwd1">decltype</span><span class="round">(</span>
      <span class="round">(</span><span class="op">*</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Tp1</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">)</span><span class="op">.*</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Fp</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span>
      <span class="round">)</span><span class="op">,</span> <span class="ident">__invoke_memobj_deref</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj_deref</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__result_of_memobj_deref_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span>
        <span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">_Argval</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span> <span class="ident">_MemPtr</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_same</span><span class="op">&lt;</span><span class="ident">_Argval</span><span class="op">,</span> <span class="ident">_Class</span><span class="op">&gt;</span><span class="op">,</span>
        <span class="ident">is_base_of</span><span class="op">&lt;</span><span class="ident">_Class</span><span class="op">,</span> <span class="ident">_Argval</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
        <span class="ident">__result_of_memobj_ref</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">,</span>
        <span class="ident">__result_of_memobj_deref</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
      <span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">::</span><span class="ident">type</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">remove_cv</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span>
        <span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span> <span class="ident">_Argval</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span> <span class="ident">_MemPtr</span><span class="op">;</span>
      <span class="kwd1">typedef</span> <span class="kwd1">typename</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">__or_</span><span class="op">&lt;</span><span class="ident">is_same</span><span class="op">&lt;</span><span class="ident">_Argval</span><span class="op">,</span> <span class="ident">_Class</span><span class="op">&gt;</span><span class="op">,</span>
        <span class="ident">is_base_of</span><span class="op">&lt;</span><span class="ident">_Class</span><span class="op">,</span> <span class="ident">_Argval</span><span class="op">&gt;&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
        <span class="ident">__result_of_memfun_ref</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">,</span>
        <span class="ident">__result_of_memfun_deref</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
      <span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">::</span><span class="ident">type</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
  <span class="cmnt">// 2219.  INVOKE-ing a pointer to member with a reference_wrapper</span>
  <span class="cmnt">//        as the object expression</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memobj_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memobj_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memobj_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memobj_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;&amp;</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memobj_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memfun_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;</span><span class="op">,</span>
                    <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memfun_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;</span><span class="op">,</span>
                  <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memfun_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;&amp;</span><span class="op">,</span>
                  <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memfun_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Res</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Class</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="kwd1">const</span> <span class="ident">reference_wrapper</span><span class="op">&lt;</span><span class="ident">_Arg</span><span class="op">&gt;</span><span class="op">&amp;&amp;</span><span class="op">,</span>
                  <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="ident">__result_of_memfun_ref</span><span class="op">&lt;</span><span class="ident">_Res</span> <span class="ident">_Class</span><span class="op">::</span><span class="op">*</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&amp;</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">bool</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Functor</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="ident">__failure_type</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_impl</span><span class="op">&lt;</span><span class="kwd1">true</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__result_of_memobj</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">decay</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_impl</span><span class="op">&lt;</span><span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">true</span><span class="op">,</span> <span class="ident">_MemPtr</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__result_of_memfun</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">decay</span><span class="op">&lt;</span><span class="ident">_MemPtr</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">,</span> <span class="ident">_Arg</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// [func.require] paragraph 1 bullet 5:</span>
  <span class="kwd1">struct</span> <span class="ident">__result_of_other_impl</span>
  <span class="curly">{</span>
    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Fn</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__result_of_success</span><span class="op">&lt;</span><span class="kwd1">decltype</span><span class="round">(</span>
      <span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Fn</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="round">(</span><span class="ident">std</span><span class="op">::</span><span class="ident">declval</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">&gt;</span><span class="round">(</span><span class="round">)</span><span class="op">...</span><span class="round">)</span>
      <span class="round">)</span><span class="op">,</span> <span class="ident">__invoke_other</span><span class="op">&gt;</span> <span class="ident">_S_test</span><span class="round">(</span><span class="kwd1">int</span><span class="round">)</span><span class="op">;</span>

    <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span>
      <span class="kwd1">static</span> <span class="ident">__failure_type</span> <span class="ident">_S_test</span><span class="round">(</span><span class="op">...</span><span class="round">)</span><span class="op">;</span>
  <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Functor</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__result_of_impl</span><span class="op">&lt;</span><span class="kwd1">false</span><span class="op">,</span> <span class="kwd1">false</span><span class="op">,</span> <span class="ident">_Functor</span><span class="op">,</span> <span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">private</span> <span class="ident">__result_of_other_impl</span>
    <span class="curly">{</span>
      <span class="kwd1">typedef</span> <span class="kwd1">decltype</span><span class="round">(</span><span class="ident">_S_test</span><span class="op">&lt;</span><span class="ident">_Functor</span><span class="op">,</span> <span class="ident">_ArgTypes</span><span class="op">...</span><span class="op">&gt;</span><span class="round">(</span><span class="num">0</span><span class="round">)</span><span class="round">)</span> <span class="ident">type</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Functor</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_ArgTypes</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">result_of</span><span class="op">&lt;</span><span class="ident">_Functor</span><span class="round">(</span><span class="ident">_ArgTypes</span><span class="op">...</span><span class="round">)</span><span class="op">&gt;</span>
    <span class="op">:</span> <span class="kwd1">public</span> <span class="ident">__result_of_impl</span><span class="op">&lt;</span>
        <span class="ident">is_member_object_pointer</span><span class="op">&lt;</span>
          <span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_Functor</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
        <span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
        <span class="ident">is_member_function_pointer</span><span class="op">&lt;</span>
          <span class="kwd1">typename</span> <span class="ident">remove_reference</span><span class="op">&lt;</span><span class="ident">_Functor</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
        <span class="op">&gt;</span><span class="op">::</span><span class="ident">value</span><span class="op">,</span>
        <span class="ident">_Functor</span><span class="op">,</span> <span class="ident">_ArgTypes</span><span class="op">...</span>
      <span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span>
    <span class="curly">{</span> <span class="curly">}</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201103L</span>
</span>  <span class="cmnt">/// Alias template for aligned_storage</span>
<span class="cmnt">/*
  template&lt;size_t _Len, size_t _Align =
        __alignof__(typename __aligned_storage_msa&lt;_Len&gt;::__type)&gt;
    using aligned_storage_t = typename aligned_storage&lt;_Len, _Align&gt;::type;

  template &lt;size_t _Len, typename... _Types&gt;
    using aligned_union_t = typename aligned_union&lt;_Len, _Types...&gt;::type;
*/</span>
  <span class="cmnt">/// Alias template for decay</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">decay_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">decay</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for enable_if</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span> <span class="ident">_Cond</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Tp</span> <span class="op">=</span> <span class="kwd1">void</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">enable_if_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">enable_if</span><span class="op">&lt;</span><span class="ident">_Cond</span><span class="op">,</span> <span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for conditional</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">bool</span> <span class="ident">_Cond</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Iftrue</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_Iffalse</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">conditional_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">conditional</span><span class="op">&lt;</span><span class="ident">_Cond</span><span class="op">,</span> <span class="ident">_Iftrue</span><span class="op">,</span> <span class="ident">_Iffalse</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for common_type</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">common_type_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">common_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">...</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for underlying_type</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">underlying_type_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">underlying_type</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// Alias template for result_of</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Tp</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">result_of_t</span> <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">result_of</span><span class="op">&lt;</span><span class="ident">_Tp</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span> <span class="kwd1">using</span> <span class="ident">__void_t</span> <span class="op">=</span> <span class="kwd1">void</span><span class="op">;</span>

<span class="pp">#<span class="ident">if</span> <span class="ident">__cplusplus</span> <span class="op">&gt;</span> <span class="num">201402L</span> <span class="op">||</span> <span class="op">!</span><span class="kwd2">defined</span><span class="round">(</span><span class="ident">__STRICT_ANSI__</span><span class="round">)</span> <span class="cmnt">// c++1z or gnu++11</span>
</span><span class="pp">#<span class="ident">define</span> <span class="ident">__cpp_lib_void_t</span> <span class="num">201411</span>
</span>  <span class="cmnt">/// A metafunction that always yields void, used for detecting valid types.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span> <span class="kwd1">using</span> <span class="ident">void_t</span> <span class="op">=</span> <span class="kwd1">void</span><span class="op">;</span>
<span class="pp">#<span class="ident">endif</span>
</span>
  <span class="cmnt">/// Implementation of the detection idiom (negative case).</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Default</span><span class="op">,</span> <span class="kwd1">typename</span> <span class="ident">_AlwaysVoid</span><span class="op">,</span>
        <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span> <span class="kwd1">class</span> <span class="ident">_Op</span><span class="op">,</span> <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__detector</span>
    <span class="curly">{</span>
      <span class="kwd1">using</span> <span class="ident">value_t</span> <span class="op">=</span> <span class="ident">false_type</span><span class="op">;</span>
      <span class="kwd1">using</span> <span class="ident">type</span> <span class="op">=</span> <span class="ident">_Default</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">/// Implementation of the detection idiom (positive case).</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Default</span><span class="op">,</span> <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span> <span class="kwd1">class</span> <span class="ident">_Op</span><span class="op">,</span>
        <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">struct</span> <span class="ident">__detector</span><span class="op">&lt;</span><span class="ident">_Default</span><span class="op">,</span> <span class="ident">__void_t</span><span class="op">&lt;</span><span class="ident">_Op</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;&gt;</span><span class="op">,</span> <span class="ident">_Op</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span>
    <span class="curly">{</span>
      <span class="kwd1">using</span> <span class="ident">value_t</span> <span class="op">=</span> <span class="ident">true_type</span><span class="op">;</span>
      <span class="kwd1">using</span> <span class="ident">type</span> <span class="op">=</span> <span class="ident">_Op</span><span class="op">&lt;</span><span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">;</span>
    <span class="curly">}</span><span class="op">;</span>

  <span class="cmnt">// Detect whether _Op&lt;_Args...&gt; is a valid type, use _Default if not.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Default</span><span class="op">,</span> <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span> <span class="kwd1">class</span> <span class="ident">_Op</span><span class="op">,</span>
        <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">__detected_or</span> <span class="op">=</span> <span class="ident">__detector</span><span class="op">&lt;</span><span class="ident">_Default</span><span class="op">,</span> <span class="kwd1">void</span><span class="op">,</span> <span class="ident">_Op</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">;</span>

  <span class="cmnt">// _Op&lt;_Args...&gt; if that is a valid type, otherwise _Default.</span>
  <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span> <span class="ident">_Default</span><span class="op">,</span> <span class="kwd1">template</span><span class="op">&lt;</span><span class="kwd1">typename</span><span class="op">...</span><span class="op">&gt;</span> <span class="kwd1">class</span> <span class="ident">_Op</span><span class="op">,</span>
        <span class="kwd1">typename</span><span class="op">...</span> <span class="ident">_Args</span><span class="op">&gt;</span>
    <span class="kwd1">using</span> <span class="ident">__detected_or_t</span>
      <span class="op">=</span> <span class="kwd1">typename</span> <span class="ident">__detected_or</span><span class="op">&lt;</span><span class="ident">_Default</span><span class="op">,</span> <span class="ident">_Op</span><span class="op">,</span> <span class="ident">_Args</span><span class="op">...</span><span class="op">&gt;</span><span class="op">::</span><span class="ident">type</span><span class="op">;</span>

  <span class="cmnt">/// @} group metaprogramming</span>

  <span class="cmnt">/**
   *  Use SFINAE to determine if the type _Tp has a publicly-accessible
   *  member type _NTYPE.
   */</span>
<span class="cmnt">/*
#define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)                \
  template&lt;typename _Tp, typename = __void_t&lt;&gt;&gt;                \
    struct __has_##_NTYPE                        \
    : false_type                            \
    { };                                \
  template&lt;typename _Tp&gt;                        \
    struct __has_##_NTYPE&lt;_Tp, __void_t&lt;typename _Tp::_NTYPE&gt;&gt;        \
    : true_type                                \
    { };
*/</span>

<span class="cmnt">/*

  template &lt;typename _Tp&gt;
    struct __is_swappable;

  template &lt;typename _Tp&gt;
    struct __is_nothrow_swappable;

  template&lt;typename _Tp&gt;
    inline
    typename enable_if&lt; __and_&lt;is_move_constructible&lt;_Tp&gt;
                      , is_move_assignable&lt;_Tp&gt;
                      &gt;::value&gt;::type
    swap(_Tp&amp;, _Tp&amp;)
    noexcept(__and_&lt;is_nothrow_move_constructible&lt;_Tp&gt;,
                is_nothrow_move_assignable&lt;_Tp&gt;&gt;::value);

  template&lt;typename _Tp, size_t _Nm&gt;
    inline
    typename enable_if&lt; __is_swappable&lt;_Tp&gt;::value &gt;::type
    swap(_Tp (&amp;__a)[_Nm], _Tp (&amp;__b)[_Nm])
    noexcept(__is_nothrow_swappable&lt;_Tp&gt;::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template&lt;typename _Tp, typename
               = decltype(swap(std::declval&lt;_Tp&amp;&gt;(), std::declval&lt;_Tp&amp;&gt;()))&gt;
        static true_type __test(int);

      template&lt;typename&gt;
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template&lt;typename _Tp&gt;
        static __bool_constant&lt;
          noexcept(swap(std::declval&lt;_Tp&amp;&gt;(), std::declval&lt;_Tp&amp;&gt;()))
        &gt; __test(int);

      template&lt;typename&gt;
        static false_type __test(...);
    };

  }

  template&lt;typename _Tp&gt;
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test&lt;_Tp&gt;(0)) type;
    };

  template&lt;typename _Tp&gt;
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test&lt;_Tp&gt;(0)) type;
    };

  template&lt;typename _Tp&gt;
    struct __is_swappable
    : public __is_swappable_impl&lt;_Tp&gt;::type
    { };

  template&lt;typename _Tp&gt;
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl&lt;_Tp&gt;::type
    { };
*/</span>


<span class="curly">}</span><span class="op">;</span> <span class="cmnt">// namespace std</span>


<span class="pp">#<span class="ident">endif</span> <span class="cmnt">//#if defined(UMBA_CXX_HAS_STD11)</span>
</span>
</pre>
</body>
</html>
